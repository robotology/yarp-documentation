<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Port Power, Going Further with Ports</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.2.2' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('port_expert.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Port Power, Going Further with Ports </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#port_expert_basic">Streaming messages</a></li>
<li class="level1"><a href="#port_expert_timing">Decoupling sender/receiver timing</a></li>
<li class="level1"><a href="#port_expert_polling">Polling ports</a></li>
<li class="level1"><a href="#port_expert_callbacks">Getting a callback</a></li>
<li class="level1"><a href="#port_expert_reply">Getting replies</a></li>
<li class="level1"><a href="#port_expert_data">Datatypes</a></li>
<li class="level1"><a href="#port_expert_carriers">Carriers</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial builds on the material in <a class="el" href="note_ports.html">Getting Started with YARP Ports</a>, and takes a deeper look at what ports can do for you.</p>
<ul>
<li>The code fragments in this tutorial are expanded into self-contained programs in the example/port_power directory of the YARP repository.</li>
</ul>
<h1><a class="anchor" id="port_expert_basic"></a>
Streaming messages</h1>
<p>The fundamental class for communication in yarp is <a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a>. Ports have names and can connect to any number of other Ports. Data flows along these connections. YARP has a strong bias towards "streaming" communication, where the sender of data is maximally decoupled from the receiver of data, but also supports "send/reply" communication where sender and receiver are tightly coupled.</p>
<p>Here is an example of a receiver for streamed messages: </p><div class="fragment"><div class="line">Port p;            <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/in&quot;</span>);     <span class="comment">// Give it a name on the network.</span></div>
<div class="line">Bottle b;          <span class="comment">// Make a place to store things.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  p.read(b);         <span class="comment">// Read from the port.  Waits until data arrives.</span></div>
<div class="line">  ...                <span class="comment">// Do something with data.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is an example of a sender of streamed messages: </p><div class="fragment"><div class="line">Port p;            <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/out&quot;</span>);    <span class="comment">// Give it a name on the network.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  Bottle b;        <span class="comment">// Make a place to store things.</span></div>
<div class="line">  ...              <span class="comment">// Generate data.</span></div>
<div class="line">  p.write(b);      <span class="comment">// Send the data.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Here's an example of some code that connects the sender to the receiver: </p><div class="fragment"><div class="line">Network::connect(<span class="stringliteral">&quot;/out&quot;</span>,<span class="stringliteral">&quot;/in&quot;</span>);  <span class="comment">// connect two ports.</span></div>
</div><!-- fragment --><p>Characteristic of streaming operation, the sender and the receiver don't know much about each other. The sender or receiver could be restarted without needing to restart the other. There could be multiple receivers or multiple senders.</p>
<p>Our sender and receiver do have some dependencies on each other. In particular, once a receiver starts receiving an object, the sender must wait for that process to finish before continuing. The sender can change this behavior by calling: <a class="el" href="classyarp_1_1os_1_1Port.html#a013b993154498cd04031437049b3cb4b" title="control whether writing from this port is done in the background.">yarp::os::Port::enableBackgroundWrite()</a> before the port is opened. However, this is only appropriate if we can promise the port that any object (b in this case) we ask it to write will stay in existence until it is communicated. The port won't take a copy of our object (that is inefficient in general). We can tell when writing is finished in two ways. One is by calling <a class="el" href="classyarp_1_1os_1_1Port.html#ae10aff650a2a57a2f108e03cbd504514" title="Report whether the port is currently writing data.">yarp::os::Port::isWriting()</a>. Another is by overriding the <a class="el" href="classyarp_1_1os_1_1PortWriter.html#aac0006ec5d606d4922c0cf095577e8a8" title="This is called when the port has finished all writing operations.">yarp::os::PortWriter::onCompletion()</a> method on the object. This will be called when the port is finished with the object.</p>
<h1><a class="anchor" id="port_expert_timing"></a>
Decoupling sender/receiver timing</h1>
<p>Keeping objects around until they have been transmitted is actually quite complicated to do, especially when there are multiple receivers operating at different rates. YARP supplies the <a class="el" href="classyarp_1_1os_1_1PortWriterBuffer.html" title="Buffer outgoing data to a port.">yarp::os::PortWriterBuffer</a> class to manage these details. There is a similar class for reducing timing dependencies during reading, called <a class="el" href="classyarp_1_1os_1_1PortReaderBuffer.html" title="Buffer incoming data to a port.">yarp::os::PortReaderBuffer</a>. These two kinds of buffering are bundled with the <a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a> class in <a class="el" href="classyarp_1_1os_1_1BufferedPort.html" title="A mini-server for performing network communication in the background.">yarp::os::BufferedPort</a>. For streaming communication, this class offers many advantages. We can rewrite our previous example like this &ndash; the receiver: </p><div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; p; <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/in&quot;</span>);          <span class="comment">// Give it a name on the network.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  Bottle *b = p.read(); <span class="comment">// Read from the port.  Waits until data arrives.</span></div>
<div class="line">  ...                   <span class="comment">// Do something with data in *b.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The sender: </p><div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; p; <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/out&quot;</span>);         <span class="comment">// Give it a name on the network.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  Bottle&amp; b = p.prepare(); <span class="comment">// Get a place to store things.</span></div>
<div class="line">  ...                   <span class="comment">// Generate data.</span></div>
<div class="line">  p.write();            <span class="comment">// Send the data.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The code is very similar. The big difference is that the <a class="el" href="classyarp_1_1os_1_1BufferedPort.html" title="A mini-server for performing network communication in the background.">yarp::os::BufferedPort</a> is now responsible for the lifetime of the objects being communicated. It will make a pool of them, growing upon need, in order to give smooth performance with minimal timing dependencies between sender and receiver.</p>
<p>By default, a BufferedPort will just keep the newest message received if several have come in between calls to <a class="el" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read()</a>, dropping old messages. If you'd prefer to have all messages received, call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aecb5533cb8005f6fe4278d292ec21033" title="Call this to strictly keep all messages, or allow old ones to be quietly dropped.">yarp::os::BufferedPort::setStrict()</a>.</p>
<p>By default, if asked to send a message while some connections are still writing a previous message, BufferedPort will simply skip sending that message on those busy connections. If you'd rather all messages were send, call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#a5b162e30ad21b6c506520c4fde2c7377" title="Write the current object being returned by BufferedPort::prepare, waiting until any previous sends ar...">yarp::os::BufferedPort::writeStrict()</a> when writing.</p>
<h1><a class="anchor" id="port_expert_polling"></a>
Polling ports</h1>
<p>If you want to know if data has arrived, but don't want to wait if it has not, you can do: </p><div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; p;</div>
<div class="line">...</div>
<div class="line">Bottle *b = p.read(<span class="keyword">false</span>);</div>
<div class="line"><span class="keywordflow">if</span> (b!=NULL) {</div>
<div class="line">  <span class="comment">// data received in *b</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The read method here will return immediately if there is no data. Without the "false", it would wait until data is present.</p>
<p>It is not possible to do something like this with <a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a>, since this functionality requires buffering. You can, however, get a callback.</p>
<h1><a class="anchor" id="port_expert_callbacks"></a>
Getting a callback</h1>
<p>Often when reading from a port, it is preferable to ask the port to call a method when data arrives rather than to sit around calling <a class="el" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read()</a>. With the Port class, you can do that with the <a class="el" href="classyarp_1_1os_1_1Port.html#a1dd5e79319a03bc62d806dddc7e3df96" title="Set an external reader for port data.">yarp::os::Port::setReader()</a> method: </p><div class="fragment"><div class="line"><span class="keyword">class </span>DataProcessor : <span class="keyword">public</span> PortReader</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read</a>(ConnectionReader&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        Bottle b;</div>
<div class="line">        <span class="keywordtype">bool</span> ok = b.read(connection);</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// process data in b</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">DataProcessor processor;</div>
<div class="line">...</div>
<div class="line">p.setReader(processor);  <span class="comment">// no need to call p.read() on port any more.</span></div>
</div><!-- fragment --><p>With BufferedPorts, things are a bit easier since these ports know what type of data they are dealing with. You can override the port's onRead method: </p><div class="fragment"><div class="line"><span class="keyword">class </span>DataPort : <span class="keyword">public</span> BufferedPort&lt;Bottle&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> BufferedPort&lt;Bottle&gt;::onRead;</div>
<div class="line">    <span class="keywordtype">void</span> onRead(Bottle&amp; b)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// process data in b</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">DataPort p;</div>
<div class="line">p.useCallback();  <span class="comment">// input should go to onRead() callback</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/in&quot;</span>);</div>
</div><!-- fragment --><p> Alternatively, you can leave the port unchanged and use an external callback as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>DataProcessor : <span class="keyword">public</span> TypedReaderCallback&lt;Bottle&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="classyarp_1_1os_1_1TypedReaderCallback.html#ac7ec77e9ce88fdc3b3e5fa25e7c3b859">TypedReaderCallback&lt;Bottle&gt;::onRead</a>;</div>
<div class="line">    <span class="keywordtype">void</span> onRead(Bottle&amp; b)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// process data in b</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">DataProcessor processor;</div>
<div class="line">BufferedPort&lt;Bottle&gt; p;</div>
<div class="line">p.useCallback(processor);  <span class="comment">// input should go to processor.onRead()</span></div>
</div><!-- fragment --><h1><a class="anchor" id="port_expert_reply"></a>
Getting replies</h1>
<p>Sometimes we want to send messages and wait for replies to them. If you're considering doing this, beware &ndash; the timing of your processes is going to become tightly coupled, and a network of processes written this way is much less robust and malleable than with streaming communication. However, sometimes you really want to be sure a particular command gets through, and what the response to it is. In this case, we need something new. Messages with replies are possible with normal ports. However, this can be dangerous. For this reason YARP provides specialized classes (<a class="el" href="classyarp_1_1os_1_1RpcClient.html" title="A port that is specialized as an RPC client.">yarp::os::RpcClient</a> and <a class="el" href="classyarp_1_1os_1_1RpcServer.html" title="A port that is specialized as an RPC server.">yarp::os::RpcServer</a>) which allows to catch errors and provide informative messages (see <a class="el" href="rpc_ports.html">Specialized RPC ports</a> for details).</p>
<p>Here's how we can do it, on the sender side: </p><div class="fragment"><div class="line">RpcClient p;       <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/out&quot;</span>);    <span class="comment">// Give it a name on the network.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  Bottle in,out;   <span class="comment">// Make places to store things.</span></div>
<div class="line">  ...              <span class="comment">// prepare command &quot;out&quot;.</span></div>
<div class="line">  p.<a class="code" href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">write</a>(out,in); <span class="comment">// send command, wait for reply.</span></div>
<div class="line">  ...              <span class="comment">// process response &quot;in&quot;.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>On the receiver side: </p><div class="fragment"><div class="line">RpcServer p;       <span class="comment">// Create a port.</span></div>
<div class="line">p.open(<span class="stringliteral">&quot;/in&quot;</span>);     <span class="comment">// Give it a name on the network.</span></div>
<div class="line">Bottle in, out;    <span class="comment">// Make places to store things.</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  p.read(in,<span class="keyword">true</span>); <span class="comment">// Read from the port, and warn that we&#39;ll be replying.</span></div>
<div class="line">  ...              <span class="comment">// Do something with data, prepare reply</span></div>
<div class="line">  p.reply(out);    <span class="comment">// send reply.</span></div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>If you expect replies, it is better to use one-to-one port connections rather than many-to-many &ndash; otherwise it will get confusing.</p>
<p>If we are using callbacks, our receiver should do something like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>DataProcessor : <span class="keyword">public</span> PortReader</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read</a>(ConnectionReader&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        Bottle in, out;</div>
<div class="line">        <span class="keywordtype">bool</span> ok = in.read(connection);</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        ...      <span class="comment">// process data &quot;in&quot;, prepare &quot;out&quot;</span></div>
<div class="line">        ConnectionWriter *returnToSender = connection.getWriter();</div>
<div class="line">        <span class="keywordflow">if</span> (returnToSender!=NULL) {</div>
<div class="line">            out.write(*returnToSender);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">DataProcessor processor;</div>
<div class="line">...</div>
<div class="line">p.setReader(processor);  <span class="comment">// no need to call p.read() on port any more.</span></div>
</div><!-- fragment --><p>(Technical note: beware that the requested reply does not happen until the end of the DataProcessor <a class="el" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read()</a> method, since only then is the full size of the reply known and some lower-level network protocols require that information to be send in a header.)</p>
<p>Expecting replies is incompatible with buffering, and so can't be done with the <a class="el" href="classyarp_1_1os_1_1BufferedPort.html" title="A mini-server for performing network communication in the background.">yarp::os::BufferedPort</a> class. There's simply no way to isolate the timing of the sender and receiver in this case, since the one is explicitly waiting for the other to do some processing and respond.</p>
<p>There is a <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aff376a6782614c95a2f5a4300d1e3d36" title="If a message is received that requires a reply, use this handler.">yarp::os::BufferedPort::setReplier()</a> method which can be used to establish a "replier" for buffered ports. If someone connects to these ports and requests them to reply, this callback will be used (bypassing buffering).</p>
<h1><a class="anchor" id="port_expert_data"></a>
Datatypes</h1>
<p>What kind of data can be sent on ports? Anything you like, YARP doesn't care. If you communicate between machines with different OSes and compilers, you may need to be careful if you send your own custom data-typle, but apart from that there's no limit.</p>
<p>Suppose you have the following data-structure: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Target {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">int</span> x;</div>
<div class="line">   <span class="keywordtype">int</span> y;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Then you can create a buffered port for it this way: </p><div class="fragment"><div class="line">BufferedPort&lt; BinPortable&lt;Target&gt; &gt; port;</div>
</div><!-- fragment --><p> The <a class="el" href="classyarp_1_1os_1_1BinPortable.html" title="Class for writing and reading simple binary structures.">yarp::os::BinPortable</a> class tells YARP that you want to send the Target type across the network by encoding it exactly as it is represented in memory. The method <a class="el" href="classyarp_1_1os_1_1BinPortable.html#ad616d210993280b83023aa1d6f8e48d8" title="Get the internal structure that will be read or written.">yarp::os::BinPortable::content()</a> will give you access to the actual Target object.</p>
<p>If you try this between, say, an intel machine and a non-intel Mac, you'll run into trouble since integers are represented in different ways on these machines ("big-endian" versus "little-endian"). If you try it between machines with different compilers, you may have trouble too &ndash; compilers may add different amounts of "padding" into your structure</p>
<p>If you define your data-structure as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="system_8h.html">yarp/conf/system.h</a>&gt;</span></div>
<div class="line"><a class="code" href="system_8h.html#ad32ad21c96f2b97e862fb352c8a01e9b">YARP_BEGIN_PACK</a></div>
<div class="line"><span class="keyword">class </span>Target {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> x;</div>
<div class="line">  <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> y;</div>
<div class="line">};</div>
<div class="line"><a class="code" href="system_8h.html#a241e6c68ba31a80eb2756a0a57935fb6">YARP_END_PACK</a></div>
</div><!-- fragment --><p> Then you'll be in better shape. The integers now have a well defined representation, and the compiler is requested not to introduce padding. So this is a portable representation.</p>
<p>Even better, for YARP, is to add in a small "header" that describes your data-type. If you defined Target as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="system_8h.html">yarp/conf/system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Bottle_8h.html">yarp/os/Bottle.h</a>&gt;</span></div>
<div class="line"><a class="code" href="system_8h.html#ad32ad21c96f2b97e862fb352c8a01e9b">YARP_BEGIN_PACK</a></div>
<div class="line"><span class="keyword">class </span>Target {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> tag;</div>
<div class="line">    <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> len;</div>
<div class="line">    <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> x;</div>
<div class="line">    <a class="code" href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">NetInt32</a> y;</div>
<div class="line">    Target() {</div>
<div class="line">        tag = <a class="code" href="Bottle_8h.html#ae7e842dd9a45a5a1484d3e133f45b332">BOTTLE_TAG_LIST</a> + <a class="code" href="Bottle_8h.html#a73e0704350fce0d43c395321b74ec5fa">BOTTLE_TAG_INT32</a>;</div>
<div class="line">        len = 2;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code" href="system_8h.html#a241e6c68ba31a80eb2756a0a57935fb6">YARP_END_PACK</a></div>
</div><!-- fragment --><p>Then suddenly ports carrying this data become a lot easy to interoperate with. You can read from them using "yarp read", write to them using "yarp write", send/reply to them using "yarp rpc". You can even connect your own sockets to them without using YARP to write their values in a standard, document text/binary format. You may not see why you'd want to do any of that today, but it might be worth bearing in mind for the future.</p>
<p>More usually, rather than sending memory images across the network (a procedure fraught with gotchas), it is better to provide explicit serialization methods for your class by implementing the <a class="el" href="classyarp_1_1os_1_1Portable.html" title="This is a base class for objects that can be both read from and be written to the YARP network.">yarp::os::Portable</a> interface. For example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Target : <span class="keyword">public</span> Portable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keywordtype">int</span> y;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">write</a>(ConnectionWriter&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    connection.appendInt32(x);</div>
<div class="line">    connection.appendInt32(y);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read</a>(ConnectionReader&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    x = connection.expectInt32();</div>
<div class="line">    y = connection.expectInt32();</div>
<div class="line">    <span class="keywordflow">return</span> !connection.isError();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> See the <a class="el" href="classyarp_1_1os_1_1ConnectionWriter.html" title="An interface for writing to a network connection.">yarp::os::ConnectionWriter</a> and <a class="el" href="classyarp_1_1os_1_1ConnectionReader.html" title="An interface for reading from a network connection.">yarp::os::ConnectionReader</a> for the serialization methods available. These take care of using neutral formats for your data types. Now you no longer need the BinPortable wrapper: </p><div class="fragment"><div class="line">BufferedPort&lt;Target&gt; port;</div>
</div><!-- fragment --><p> This is how classes like <a class="el" href="classyarp_1_1os_1_1Bottle.html" title="A simple collection of objects that can be described and transmitted in a portable way.">yarp::os::Bottle</a> work.</p>
<p>There is one other thing you might like to consider when deciding how to express your data on the network. If you embed a few "tags" in your data, then it can be made compatible with the network format used by Bottles. Then ports using the format can be read from and written to the command line (with "yarp read", "yarp write", and "yarp
rpc"), or a web-browser, etc. For example, we could make Target's write method be: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">write</a>(ConnectionWriter&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  connection.appendInt32(<a class="code" href="Bottle_8h.html#ae7e842dd9a45a5a1484d3e133f45b332">BOTTLE_TAG_LIST</a>+<a class="code" href="Bottle_8h.html#a73e0704350fce0d43c395321b74ec5fa">BOTTLE_TAG_INT32</a>);</div>
<div class="line">  connection.appendInt32(2); <span class="comment">// two elements</span></div>
<div class="line">  connection.appendInt32(x);</div>
<div class="line">  connection.appendInt32(y);</div>
<div class="line">  connection.convertTextMode(); <span class="comment">// if connection is text-mode, convert!</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The first integer added says that the data is a list of integers. The second integer says there are 2 integers. The call to <a class="el" href="classyarp_1_1os_1_1ConnectionWriter.html#a956ea305a90051f85633b02217ab3386" title="Converts a standard description in binary into a textual description, if the connection is in text-mo...">yarp::os::ConnectionWriter::convertTextMode</a> is a friendly thing to do. It means if someone connects to a port outputting this data, and they are in text-mode, they will see our two integers in text form. The conversion is done by reading the data we've written as a Bottle, and then expressing that Bottle in text form.</p>
<p>The corresponding read method would be: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">read</a>(ConnectionReader&amp; connection)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  connection.convertTextMode(); <span class="comment">// if connection is text-mode, convert!</span></div>
<div class="line">  <span class="keywordtype">int</span> tag = connection.expectInt32();</div>
<div class="line">  <span class="keywordflow">if</span> (tag!=<a class="code" href="Bottle_8h.html#ae7e842dd9a45a5a1484d3e133f45b332">BOTTLE_TAG_LIST</a>+<a class="code" href="Bottle_8h.html#a73e0704350fce0d43c395321b74ec5fa">BOTTLE_TAG_INT32</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordtype">int</span> ct = connection.expectInt32();</div>
<div class="line">  <span class="keywordflow">if</span> (ct!=2) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  x = connection.expectInt32();</div>
<div class="line">  y = connection.expectInt32();</div>
<div class="line">  <span class="keywordflow">return</span> !connection.isError();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The advantages of doing this are for testing - no need to write special purpose test programs to send and read particular messages, the yarp tools already work. The disadvange is you have to do a bit more work. It is entirely up to you, this issue is independent of the rest of YARP.</p>
<p><b>NOTE:</b> For automatic text conversion to work, your message will need to be represented as a list at the top level. If you try to send a single integer, for example, translation will not work. This is because we chose to omit parentheses from lists at the top level of messages in text-mode, so there would be no way to differentiate a list containing an integer from an integer on its own.</p>
<h1><a class="anchor" id="port_expert_carriers"></a>
Carriers</h1>
<p>We've said a lot about communication. But what exactly happens when you read or write? What bytes get sent on the network? How reliable is transmission? The previous sections on datatypes and replies have started to touch on such issues, and now we go into more detail.</p>
<p>The first thing to realize is that we are now looking closely at the connections between ports, rather than the ports themselves. The properties of connections are quite loosely coupled with ports. We are free to implement connections in all sorts of weird and wonderful ways, and ports won't care at all. The abstraction in yarp for what a connection really does is called a "Carrier". There are currently carriers for tcp, udp, multi-cast, and shared memory communication. There's nothing to stop you adding more if you have some novel kind of network, or want to send messages via audio, etc. Ports will still work.</p>
<p>Carriers can be connection based (tcp, shmem) or connectionless (udp, mcast). Be aware that on connectionless carriers data flows in one direction only. As a consequence of this, replies are not possible. Data transmission may also be unreliable for such carriers. YARP guarantees that if a message is sent and successfully received, it has not been corrupted. For connectionless carriers it does not guarantee that the message will in fact be received.</p>
<p>Ideally, for all carriers, YARP will send messages of arbitrary length. At the time of writing, there is a limit on shmem message sizes.</p>
<p>There are some extra carriers designed to be as simple as possible for programs not written in YARP to use. One of these is the "text" Carrier. This allows messages in bottle-compatible format to be sent as plain text.</p>
<p>There is experimental support for http, as a way to browse port information from a browser. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceyarp_1_1sig_1_1file_html_a07569dcd80588910b9f97d167185e870"><div class="ttname"><a href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">yarp::sig::file::read</a></div><div class="ttdeci">bool read(ImageOf&lt; PixelRgb &gt; &amp;dest, const std::string &amp;src, image_fileformat format=FORMAT_ANY)</div><div class="ttdef"><b>Definition:</b> <a href="ImageFile_8cpp_source.html#l00516">ImageFile.cpp:516</a></div></div>
<div class="ttc" id="asystem_8h_html_a241e6c68ba31a80eb2756a0a57935fb6"><div class="ttname"><a href="system_8h.html#a241e6c68ba31a80eb2756a0a57935fb6">YARP_END_PACK</a></div><div class="ttdeci">#define YARP_END_PACK</div><div class="ttdoc">Ends 1 byte packing for structs/classes.</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00194">system.h:194</a></div></div>
<div class="ttc" id="aBottle_8h_html_ae7e842dd9a45a5a1484d3e133f45b332"><div class="ttname"><a href="Bottle_8h.html#ae7e842dd9a45a5a1484d3e133f45b332">BOTTLE_TAG_LIST</a></div><div class="ttdeci">#define BOTTLE_TAG_LIST</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8h_source.html#l00030">Bottle.h:30</a></div></div>
<div class="ttc" id="asystem_8h_html_ad32ad21c96f2b97e862fb352c8a01e9b"><div class="ttname"><a href="system_8h.html#ad32ad21c96f2b97e862fb352c8a01e9b">YARP_BEGIN_PACK</a></div><div class="ttdeci">#define YARP_BEGIN_PACK</div><div class="ttdoc">Starts 1 byte packing for structs/classes.</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00193">system.h:193</a></div></div>
<div class="ttc" id="aBottle_8h_html_a73e0704350fce0d43c395321b74ec5fa"><div class="ttname"><a href="Bottle_8h.html#a73e0704350fce0d43c395321b74ec5fa">BOTTLE_TAG_INT32</a></div><div class="ttdeci">#define BOTTLE_TAG_INT32</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8h_source.html#l00023">Bottle.h:23</a></div></div>
<div class="ttc" id="asystem_8h_html"><div class="ttname"><a href="system_8h.html">system.h</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_a1b49511d808f5731e2f7cf9e9831ff5e"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">yarp::os::Port::write</a></div><div class="ttdeci">bool write(const PortWriter &amp;writer, const PortWriter *callback=nullptr) const override</div><div class="ttdoc">Write an object to the port.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00422">Port.cpp:422</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1TypedReaderCallback_html_ac7ec77e9ce88fdc3b3e5fa25e7c3b859"><div class="ttname"><a href="classyarp_1_1os_1_1TypedReaderCallback.html#ac7ec77e9ce88fdc3b3e5fa25e7c3b859">yarp::os::TypedReaderCallback&lt; Bottle &gt;::onRead</a></div><div class="ttdeci">virtual void onRead(Bottle &amp;datum)</div><div class="ttdoc">Callback method.</div><div class="ttdef"><b>Definition:</b> <a href="TypedReaderCallback-inl_8h_source.html#l00043">TypedReaderCallback-inl.h:24</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1sig_1_1file_html_ab329defdeb7a6f62ebc1ce82978e69c5"><div class="ttname"><a href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">yarp::sig::file::write</a></div><div class="ttdeci">bool write(const ImageOf&lt; PixelRgb &gt; &amp;src, const std::string &amp;dest, image_fileformat format=FORMAT_PPM)</div><div class="ttdef"><b>Definition:</b> <a href="ImageFile_8cpp_source.html#l00553">ImageFile.cpp:553</a></div></div>
<div class="ttc" id="aBottle_8h_html"><div class="ttname"><a href="Bottle_8h.html">Bottle.h</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1os_html_ab2676e32122f2ffd9eeb4301a2c06b4f"><div class="ttname"><a href="namespaceyarp_1_1os.html#ab2676e32122f2ffd9eeb4301a2c06b4f">yarp::os::NetInt32</a></div><div class="ttdeci">std::int32_t NetInt32</div><div class="ttdoc">Definition of the NetInt32 type.</div><div class="ttdef"><b>Definition:</b> <a href="NetInt32_8h_source.html#l00033">NetInt32.h:33</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.2.2</span></li>
    <li class="footer">Generated on Tue Nov 3 2020 16:49:13 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
