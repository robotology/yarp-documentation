<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Creating carriers for new kinds of connections</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.2.2' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('carrier_expert.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Creating carriers for new kinds of connections </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#carrier_expert_strategy">The steps</a></li>
<li class="level1"><a href="#carrier_expert_preliminaries">Coding preliminaries</a></li>
<li class="level1"><a href="#carrier_expert_classes">Important classes</a></li>
<li class="level1"><a href="#carrier_expert_basics">The basics</a></li>
<li class="level1"><a href="#carrier_expert_example">A first example</a></li>
<li class="level1"><a href="#carrier_expert_custom">Customizing behavior</a></li>
<li class="level1"><a href="#carrier_expert_header_phase">The header and header reply phase</a></li>
<li class="level1"><a href="#carrier_expert_payload_phase">The index, payload, and ack stage</a></li>
<li class="level1"><a href="#carrier_expert_packets">An important detail: packets</a></li>
<li class="level1"><a href="#carrier_export_complete">A complete example</a></li>
</ul>
</div>
<div class="textblock"><p>In YARP, ports talk to each other via connections.</p>
<p>Connection data is carried by TCP by default, but this can be switched very easily to other "carriers". See <a class="el" href="carrier_config.html">Configuring YARP Connections</a> for information about how to configure connections using existing carriers. Here, we are going to look at creating entirely new kinds of carriers. Why might you want to do this?</p>
<ul>
<li>You need to use an unusual kind of network that no YARP user has yet worked with.</li>
</ul>
<ul>
<li>You don't like some aspect of YARP's current carriers. No problem, just make your own variation and plug it in.</li>
</ul>
<ul>
<li>You want to support network-level interoperation with non-YARP based programs.</li>
</ul>
<h1><a class="anchor" id="carrier_expert_strategy"></a>
The steps</h1>
<p>Carriers are created by implementing the <a class="el" href="classyarp_1_1os_1_1Carrier.html" title="A base class for connection types (tcp, mcast, shmem, ...) which are called carriers in YARP.">yarp::os::Carrier</a> interface. If you are creating a carrier that uses TCP, that is all you need to do.</p>
<p>If you are creating a carrier that uses a very different kind of network than anything already in YARP, you may need to go down a level further. Before you can make a carrier, you need to have a "stream" class (implementing <a class="el" href="classyarp_1_1os_1_1TwoWayStream.html" title="A stream which can be asked to perform bidirectional communication.">yarp::os::TwoWayStream</a>) that supports shipping raw data back and forth on that network. You don't need to worry about YARP protocol issues when making this class, it is just about being able to read and write raw data.</p>
<p>If you want to replace TCP entirely, for the initial handshaking done when setting up a connection, you'll need to do a bit more work. You'll need to squeeze any addressing information for your network into the <a class="el" href="classyarp_1_1os_1_1Contact.html" title="Represents how to reach a part of a YARP network.">yarp::os::Contact</a> class (or else you can extend that class). And you'll need to implement a subclass of yarp::os::impl::Face that operates like <a class="el" href="classyarp_1_1os_1_1impl_1_1TcpFace.html" title="Communicating with a port via TCP.">yarp::os::impl::TcpFace</a>. So that's a bit more work. I wouldn't recommend that being the first new carrier you make, try something simpler first to get used to how things work.</p>
<h1><a class="anchor" id="carrier_expert_preliminaries"></a>
Coding preliminaries</h1>
<p>The implementation of carriers is in the namespace <a class="el" href="namespaceyarp_1_1os_1_1impl.html" title="The components from which ports and connections are built.">yarp::os::impl</a>, rather than the regular namespace <a class="el" href="namespaceyarp_1_1os.html" title="An interface to the operating system, including Port based communication.">yarp::os</a>. Be warned that classes in the <a class="el" href="namespaceyarp_1_1os_1_1impl.html" title="The components from which ports and connections are built.">yarp::os::impl</a> ("implementation") namespace may change more from release to release than those in <a class="el" href="namespaceyarp_1_1os.html" title="An interface to the operating system, including Port based communication.">yarp::os</a> (intended to be a stable user API).</p>
<p>Header files for implementation classes may have dependencies on header files from the ACE library. This means that you need to take some care to make sure that the ACE header files on your system match those used to compile YARP.</p>
<h1><a class="anchor" id="carrier_expert_classes"></a>
Important classes</h1>
<p>You should skim the documentation of the following classes:</p>
<ul>
<li><a class="el" href="classyarp_1_1os_1_1Carrier.html" title="A base class for connection types (tcp, mcast, shmem, ...) which are called carriers in YARP.">yarp::os::Carrier</a> </li>
<li><a class="el" href="classyarp_1_1os_1_1Carriers.html" title="Collection of carriers, a singleton.">yarp::os::Carriers</a> </li>
<li><a class="el" href="classyarp_1_1os_1_1InputStream.html" title="Simple specification of the minimum functions needed from input streams.">yarp::os::InputStream</a> </li>
<li><a class="el" href="classyarp_1_1os_1_1OutputStream.html" title="Simple specification of the minimum functions needed from output streams.">yarp::os::OutputStream</a> </li>
<li><a class="el" href="classyarp_1_1os_1_1TwoWayStream.html" title="A stream which can be asked to perform bidirectional communication.">yarp::os::TwoWayStream</a> </li>
<li><a class="el" href="classyarp_1_1os_1_1Contact.html" title="Represents how to reach a part of a YARP network.">yarp::os::Contact</a></li>
</ul>
<p>You'll be able to include them in your code as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carrier_8h.html">yarp/os/Carrier.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carriers_8h.html">yarp/os/Carriers.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TwoWayStream_8h.html">yarp/os/TwoWayStream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="InputStream_8h.html">yarp/os/InputStream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="OutputStream_8h.html">yarp/os/OutputStream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Contact_8h.html">yarp/os/Contact.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceyarp_1_1os.html">yarp::os</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceyarp_1_1os_1_1impl.html">yarp::os::impl</a>;</div>
</div><!-- fragment --><h1><a class="anchor" id="carrier_expert_basics"></a>
The basics</h1>
<p>A few things you need to know. An important property of YARP carriers is that they do not need to be constant throughout a connection. So, for example, a connection may begin using a TCP carrier (and in practice all connections currently do in fact start with TCP, though this is not required), and then switch to something more efficient after some handshaking. So watch out for that. In the <a class="el" href="yarp_guts.html">YARP Guts</a> tutorial, you can see a little more how a carrier and connections relate.</p>
<p>When a port is registered with the YARP name server, an initial carrier type is specified. For example, the port associated with the name server itself might be registered as:</p>
<pre class="fragment">  registration name /root ip 192.168.1.3 port 10000 type tcp
</pre><p>The "tcp" type specified there does not necessarily mean that this port can only accept "tcp" carriers, it just means that that is how one should begin a connection to this port.</p>
<p>The first eight bytes sent on a connection are special in YARP. They act as a "magic number" for identifying the carrier to switch to. Some flags for identifying variants of a carrier might be included as well. This is a lot like how common file formats work and other network protocols work. See <a class="el" href="yarp_protocol.html">Port and connection protocols</a> for a table of "official" YARP magic numbers.</p>
<p>Once you've made up a new eight-byte sequence to name your new carrier, you then have a huge amount of freedom in how it works. The abstract phases of YARP communication are specified, but their representation "on the wire" is basically up to you. This means you have a decent shot at matching some other protocol you might have to interface with. Even the required eight-byte sequence requirement can be loosened, with a bit of care.</p>
<h1><a class="anchor" id="carrier_expert_example"></a>
A first example</h1>
<p>Here is a example that takes an existing carrier, the <a class="el" href="carrier_config.html#carrier_config_text">ordinary text-mode carrier</a>, and modifies it slightly (see example/carrier/carrier_stub.cpp). The change is very small; we name our new carrier "test" (as opposed to "text") and change its identifying 8-byte header from "CONNECT " to "TESTTEST".</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006-2019 Istituto Italiano di Tecnologia (IIT)</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006-2010 RobotCub Consortium</span></div>
<div class="line"><span class="comment"> * All rights reserved.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This software may be modified and distributed under the terms of the</span></div>
<div class="line"><span class="comment"> * BSD-3-Clause license. See the accompanying LICENSE file for details.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="libYARP__OS_2include_2yarp_2os_2all_8h.html">yarp/os/all.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carrier_8h.html">yarp/os/Carrier.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carriers_8h.html">yarp/os/Carriers.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TextCarrier_8h.html">yarp/os/impl/TextCarrier.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TestCarrier : <span class="keyword">public</span> <a class="code" href="classyarp_1_1os_1_1impl_1_1TextCarrier.html">yarp::os::impl::TextCarrier</a></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code" href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#a0400099ff767f18e971c739846bb8844">getName</a>()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;test&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code" href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#aee9473305c5be07d1ad7c0a5f380ccb8">getSpecifierName</a>()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;TESTTEST&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> Carrier *<a class="code" href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#a73ecae4d55d566b257ea457b0d92e13d">create</a>()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> TestCarrier();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Network.html">yarp::os::Network</a> <a class="code" href="namespaceyarp.html">yarp</a>;</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Carriers.html#a884ca38817eac84393e8f4ecf5b5f0f3">yarp::os::Carriers::addCarrierPrototype</a>(<span class="keyword">new</span> TestCarrier);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt;yarp::os::Bottle&gt;</a> out, in;</div>
<div class="line">    out.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#a938b0e335554aa0e7fb1d919e51a665f">open</a>(<span class="stringliteral">&quot;/test/out&quot;</span>);</div>
<div class="line">    in.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#a938b0e335554aa0e7fb1d919e51a665f">open</a>(<span class="stringliteral">&quot;/test/in&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1NetworkBase.html#a20d1100e9e9056164290a5e98e7a651d">yarp::os::Network::connect</a>(<span class="stringliteral">&quot;/test/out&quot;</span>,<span class="stringliteral">&quot;/test/in&quot;</span>,<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    out.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66">prepare</a>().<a class="code" href="classyarp_1_1os_1_1Bottle.html#a388ffac14da35ebecd8f78b642c7221b">fromString</a>(<span class="stringliteral">&quot;1 2 3&quot;</span>);</div>
<div class="line">    out.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d">write</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a> * bot = in.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">read</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (bot!=NULL) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Got message %s\n&quot;</span>, bot-&gt;<a class="code" href="classyarp_1_1os_1_1Bottle.html#ad8cb921bd7e22d6fcafc3a61db65e75c">toString</a>().c_str());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    out.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#a63c41364f3bf71d1ce68165a28f53998">close</a>();</div>
<div class="line">    in.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#a63c41364f3bf71d1ce68165a28f53998">close</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --><p>The key steps are:</p>
<ul>
<li>We create a new class for our new carrier, by subclassing something descended from <a class="el" href="classyarp_1_1os_1_1Carrier.html" title="A base class for connection types (tcp, mcast, shmem, ...) which are called carriers in YARP.">yarp::os::Carrier</a> (in this case <a class="el" href="classyarp_1_1os_1_1impl_1_1TextCarrier.html" title="Communicating between two ports via a plain-text protocol.">yarp::os::impl::TextCarrier</a>).</li>
</ul>
<ul>
<li>We make whatever customizations we want to that carrier. It is very important to override the "factory" method <a class="el" href="classyarp_1_1os_1_1Carrier.html#a173b13728a306807b3f14590439ce18b" title="Factory method.">yarp::os::Carrier::create</a> to return an instance of our new class. We also define the name associated with our class by overriding <a class="el" href="classyarp_1_1os_1_1Connection.html#a9cbef5bd6711d353c986a8a9841df91f" title="Get the name of this connection type (&quot;tcp&quot;, &quot;mcast&quot;, &quot;shmem&quot;, ...)">yarp::os::Carrier::getName</a>.</li>
</ul>
<ul>
<li>At the start of our program, we register an instance of that class in a call to <a class="el" href="classyarp_1_1os_1_1Carriers.html#a884ca38817eac84393e8f4ecf5b5f0f3" title="Add a new connection type.">yarp::os::Carriers::addCarrierPrototype</a>.</li>
</ul>
<p>Having taken those steps, we can make connections using our new carrier (called "test" in the example code):</p>
<div class="fragment"><div class="line">Network::connect(...,...,<span class="stringliteral">&quot;test&quot;</span>);</div>
</div><!-- fragment --><p>To make connections of this type from the command line with the <a class="el" href="yarp.html">yarp companion</a> (the "yarp" command), you need to insert your carrier in the YARP library, or else compile a customized version of the companion. Here is the companion's source code in its entirety:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Network_8h.html">yarp/os/Network.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceyarp_1_1os.html">yarp::os</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Network.html">Network</a> <a class="code" href="namespaceyarp.html">yarp</a>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">Network::main</a>(argc,argv);</div>
<div class="line">}</div>
</div><!-- fragment --><p>So there isn't much to it to just insert a call to Carriers::addCarrierPrototype in there. Otherwise, to put the new carrier in the YARP library proper, do a little pattern-matching in the constructor for the <a class="el" href="classyarp_1_1os_1_1Carriers.html" title="Collection of carriers, a singleton.">yarp::os::Carriers</a> class at <a class="el" href="Carriers_8cpp.html">src/libYARP_OS/src/Carriers.cpp</a>.</p>
<h1><a class="anchor" id="carrier_expert_custom"></a>
Customizing behavior</h1>
<p>The previous example just shows enough to make a carrier that is a small tweak of an existing one, but doesn't help much with setting up a completely new carrier.</p>
<p>For that, we need to make a subclass of <a class="el" href="classyarp_1_1os_1_1Carrier.html" title="A base class for connection types (tcp, mcast, shmem, ...) which are called carriers in YARP.">yarp::os::Carrier</a>. There's a lot of methods that we need to specify. First, some easy ones:</p>
<dl>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a173b13728a306807b3f14590439ce18b" title="Factory method.">yarp::os::Carrier::create</a> </dt>
<dd><p class="startdd">A factory method - just return a new instance of your carrier.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Connection.html#a9cbef5bd6711d353c986a8a9841df91f" title="Get the name of this connection type (&quot;tcp&quot;, &quot;mcast&quot;, &quot;shmem&quot;, ...)">yarp::os::Carrier::getName</a> </dt>
<dd><p class="startdd">Give the human-readable name of your carrier - this is how you would select it in "yarp connect /from /to CARRIERNAME" for example.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a02556826dcfa249a2c7b76f370cdf024" title="Check if this carrier is connectionless (like udp, mcast) or connection based (like tcp).">yarp::os::Carrier::isConnectionless</a> </dt>
<dd><p class="startdd">Return a flag specifying whether your carrier is "connection-based" or "connectionless" in the tcp/udp sense. If connectionless, YARP will assume, for example, that failures of the connection on one side may not be noticed on the other side, and take appropriate action. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ae5b353fc9d010f02e8cb4e7ab61c4bc1" title="Check if reading is implemented for this carrier.">yarp::os::Carrier::canAccept</a> </dt>
<dd><p class="startdd">Return true if your implementation can handle being the destination of a connection. Normally this should be true.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#aebe3b0066da7411b7950db3b97dcbe94" title="Check if writing is implemented for this carrier.">yarp::os::Carrier::canOffer</a> </dt>
<dd><p class="startdd">Return true if your implementation can handle being the initiator of a connection. Normally this should be true.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a53cf1b392dbc454b9a5aa53d887d7757" title="Check if carrier is textual in nature.">yarp::os::Carrier::isTextMode</a> </dt>
<dd><p class="startdd">Return true if your carrier is text-mode, for human reading/writing. YARP will use textual variants of its administrative messages if this is the case, and objects that serialize using the YARP standard "bottle" format (see <a class="el" href="data_rep.html">Standard data representation format</a>) will serialize in text form. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a3009258f3482d348b72941b5ddc8c44f" title="Check if carrier can encode administrative messages, as opposed to just user data.">yarp::os::Carrier::canEscape</a> </dt>
<dd><p class="startdd">Return true if your carrier has a way of distinguishing user payload data from administrative headers. If false, YARP will not try to send any administrative headers on your carrier (e.g. disconnection requests, for example). Normally this should be true. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#abb5e333f1c174672a42e1076448dc2f1" title="Carriers that do not distinguish data from administrative headers (i.e.">yarp::os::Carrier::handleEnvelope</a> </dt>
<dd><p class="startdd">Carriers that do not distinguish data from administrative headers (i.e. canEscape returns false), can overload this method to handle the envelope inside the stream. On the receiving side, the InputStream will have to overload the setReadEnvelopeCallback method, and execute the callback as soon as the envelope is ready. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a49d47917e4231bb17224b90abeb6d04c" title="Check if carrier has flow control, requiring sent messages to be acknowledged by recipient.">yarp::os::Carrier::requireAck</a> </dt>
<dd><p class="startdd">Does you want YARP to use flow control? If this is set, YARP will attempt to send an acknowledgement back to the sender after receiving data, even in streaming operation.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a01dd9e789b734394be9f9dbb16297b3c" title="This flag is used by YARP to determine whether the connection can carry RPC traffic,...">yarp::os::Carrier::supportReply</a> </dt>
<dd><p class="startdd">Does your carrier support bidirectional communication?</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ac61b569f9333b36f69e6ea4c38816de1" title="Check if carrier operates within a single process.">yarp::os::Carrier::isLocal</a> </dt>
<dd><p class="startdd">Is your carrier process-local? That is, it can only used by threads sharing the same memory space? This should normally be false (but, if true, YARP will make a lot of optimizations obviously).</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a0d9e6bb7d437d2e7d71238093ede1989" title="Get name of carrier.">yarp::os::Carrier::toString</a> </dt>
<dd><p class="startdd">Give a textual representation of the state of the carrier. There is no standard for this, it is not much used.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Okay, that's a lot of stuff, but it is all "meta-data" - it describes your carrier, but doesn't implement it. It is important to get right though since it controls how YARP will use your carrier.</p>
<p>Now let us get down to implementation. It might be worth having <a class="el" href="yarp_protocol.html">Port and connection protocols</a> open on a page beside this one. Basically, a connection in YARP has several phases:</p>
<ul>
<li>
<p class="startli">Initiation phase - an initial connection is been made.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Header phase - the initiator of the connection sends an 8 byte "magic number" identifying the desired carrier type. The recipient of the connection waits for that 8 byte number. Once that is done, the carrier implementer is free to add on any further information they'd like to send. Carriers are strongly encouraged to send the name of the port associated with the initiator of the connection, but are free to do this however they like.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Header reply phase - an opportunity for the recipient to talk back to the initiator, if needed. Carriers are free to do what they want here, including extended bidirectional communication.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Index phase - when the user (or YARP wants) to send data over the connection, the carrier is given the opportunity to send some prior information (for example, lengths).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Payload data phase - here the carrier encodes user (or YARP) data.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Acknowledgement phase - if the carrier wants acknowledgements to happen, this is when YARP will request them. If a reply from the other side is expected, this will happen before the acknowledgement. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">...and we loop back to the index phase.</p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="carrier_expert_header_phase"></a>
The header and header reply phase</h1>
<p>The first set of methods needed are those to create or check the 8-byte "magic number" identifying the carrier type. We label the methods as INITIATOR for methods that matter on the side that initiates a connection, and RECIPIENT for the other side.</p>
<dl>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ad72cf75308c524aadc24a5bc6797ce23" title="Provide 8 bytes describing this connection sufficiently to allow the other side of a connection to se...">yarp::os::Carrier::getHeader</a> (INITIATOR) </dt>
<dd><p class="startdd">Place an 8-byte "magic number" describing the carrier in the block of memory provided.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ade8595d49121366dbd059c00e07032dd" title="Given the first 8 bytes received on a connection, decide if this is the right carrier type to use for...">yarp::os::Carrier::checkHeader</a> (RECIPIENT) </dt>
<dd><p class="startdd">Check whether the "magic number" passed describes your carrier.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#aa8bd0df9aab08d985972c36adc176ba5" title="Configure this carrier based on the first 8 bytes of the connection.">yarp::os::Carrier::setParameters</a> (RECIPIENT) </dt>
<dd><p class="startdd">Configure the carrier based on parameters that might be embedded within the "magic number" passed. You can assume that the Carrier::checkHeader test has already succeeded. For carriers with no variants, this method will do nothing. </p>
<p class="enddd"></p>
</dd>
</dl>
<p>Now we need to set up a series of callbacks which are invoked during the header and header reply phases.</p>
<dl>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#af97ef0bf594a93906dbb451b2835e172" title="Perform any initialization needed before writing on a connection.">yarp::os::Carrier::prepareSend</a> (INITIATOR) </dt>
<dd><p class="startdd">Called just before we start writing on a connection. It is fine to do nothing here, this method is not really needed and is there for historical reasons.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a8b607f200b8b5ecd8d3abc2b37526e5a" title="Write a header appropriate to the carrier to the connection, followed by any carrier-specific data.">yarp::os::Carrier::sendHeader</a> (INITIATOR) </dt>
<dd><p class="startdd">Finally, we send some data! This method should first send the 8 bytes determined by <a class="el" href="classyarp_1_1os_1_1Carrier.html#ad72cf75308c524aadc24a5bc6797ce23" title="Provide 8 bytes describing this connection sufficiently to allow the other side of a connection to se...">yarp::os::Carrier::getHeader</a>. The "proto" object you are passed has an OutputStream object accessible as <a class="el" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140" title="Shorthand for getOutputStream()">yarp::os::ConnectionState::os()</a> upon which you can write (you are passed a protocol object as an argument in this and most other callbacks). Be sure to flush after writing these 8 bytes. After that, you're free to send anything else you feel you need to. You should definitely pass the name of the originating port, if there is one, so that the recipient knows who it is talking to. You can get that information from proto.getRoute().getFromName() (<a class="el" href="classyarp_1_1os_1_1ConnectionState.html#a47543e44a05f7508d3db1069ce3f67f9" title="Get the route associated with this connection.">yarp::os::ConnectionState::getRoute()</a>, <a class="el" href="classyarp_1_1os_1_1Route.html#a9beaa65ef1683ab12367720e2e98d0f8" title="Get the source of the route.">yarp::os::Route::getFromName()</a>). </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a717a57569bd043f969a6e265e78075ac" title="Expect the name of the sending port.">yarp::os::Carrier::expectSenderSpecifier</a> (RECIPIENT) </dt>
<dd><p class="startdd">On the receiving side, the first 8 bytes are received by YARP and used to set up your carrier (via <a class="el" href="classyarp_1_1os_1_1Carrier.html#ade8595d49121366dbd059c00e07032dd" title="Given the first 8 bytes received on a connection, decide if this is the right carrier type to use for...">yarp::os::Carrier::checkHeader</a> and <a class="el" href="classyarp_1_1os_1_1Carrier.html#aa8bd0df9aab08d985972c36adc176ba5" title="Configure this carrier based on the first 8 bytes of the connection.">yarp::os::Carrier::setParameters</a>). After that is done, the <a class="el" href="classyarp_1_1os_1_1Carrier.html#a717a57569bd043f969a6e265e78075ac" title="Expect the name of the sending port.">yarp::os::Carrier::expectSenderSpecifier</a> is called. Your job is to pick up the name of the originating port, however you chose to send it in <a class="el" href="classyarp_1_1os_1_1Carrier.html#a8b607f200b8b5ecd8d3abc2b37526e5a" title="Write a header appropriate to the carrier to the connection, followed by any carrier-specific data.">yarp::os::Carrier::sendHeader</a>, and then inform YARP about it by calling proto.setRoute(proto.getRoute().addFromName(PORT_NAME)). You have access to an InputStream as proto.is() [SIDE NOTE: yes, the API between Carrier and Protocol is a bit cumbersome and over-exposes the implementation. Sorry!] </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ab94dbc75892185f10eda8e93004dec30" title="Receive any carrier-specific header.">yarp::os::Carrier::expectExtraHeader</a> (RECIPIENT) </dt>
<dd><p class="startdd">Called after <a class="el" href="classyarp_1_1os_1_1Carrier.html#a717a57569bd043f969a6e265e78075ac" title="Expect the name of the sending port.">yarp::os::Carrier::expectSenderSpecifier</a>. You can process more header information here if there is any. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a202825b56a69d0e3fbccd3154eed3c90" title="Respond to the header.">yarp::os::Carrier::respondToHeader</a> (RECIPIENT) </dt>
<dd><p class="startdd">An opportunity to send data back to the initiator, if needed. Use the proto.os() stream. Fine to do nothing.</p>
<p class="interdd">This is also the moment to optionally drop the current input/output streams associated with the connection (probably TCP) and create an entirely different set (e.g. MCAST, UDP, SHMEM, or whatever kind of communication you are going to use). The easiest way to do that is to create suitable <a class="el" href="classyarp_1_1os_1_1InputStream.html" title="Simple specification of the minimum functions needed from input streams.">yarp::os::InputStream</a> and <a class="el" href="classyarp_1_1os_1_1OutputStream.html" title="Simple specification of the minimum functions needed from output streams.">yarp::os::OutputStream</a> implementations, and then substitute them in by calling proto.takeStreams (see <a class="el" href="classyarp_1_1os_1_1ConnectionState.html#ac552ef35e1a421b84064ca6f287be022" title="Provide streams to be used with the connection.">yarp::os::ConnectionState::takeStreams</a>). Look at <a class="el" href="UdpCarrier_8h.html">UdpCarrier.h</a> or <a class="el" href="McastCarrier_8h.html">McastCarrier.h</a> for examples.</p>
<p class="interdd"></p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#aedaef9bb02fa17594a79a42a68422a49" title="Process reply to header, if one is expected for this carrier.">yarp::os::Carrier::expectReplyToHeader</a> (INITIATOR) </dt>
<dd><p class="startdd">If the recipient does <a class="el" href="classyarp_1_1os_1_1Carrier.html#a202825b56a69d0e3fbccd3154eed3c90" title="Respond to the header.">yarp::os::Carrier::respondToHeader</a>, the initiator needs to read that data here. Further rounds of handshaking are possible, but not formalized with callbacks - just do matching read/write sequences in <a class="el" href="classyarp_1_1os_1_1Carrier.html#a202825b56a69d0e3fbccd3154eed3c90" title="Respond to the header.">yarp::os::Carrier::respondToHeader</a> and <a class="el" href="classyarp_1_1os_1_1Carrier.html#aedaef9bb02fa17594a79a42a68422a49" title="Process reply to header, if one is expected for this carrier.">yarp::os::Carrier::expectReplyToHeader</a>.</p>
<p class="interdd">This is also the moment for the initiator to optionally switch streams, in the same way as the recipient does in respondToHeader.</p>
<p class="interdd"></p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a8164ac2447f6457a3db22ca9ec8ae6ea" title="Check if carrier is alive and error free.">yarp::os::Carrier::isActive</a> </dt>
<dd><p class="startdd">Return true if your carrier should be given data to transmit, or false if it should be ignored. Almost always, returning true is what you want. However if there is a low-level implementation of broadcasting that you can exploit (as for multicast carrier), a set of "logical" connections may be identical underneath - so this method can be useful to avoid duplicate messages.</p>
<p class="interdd">If you didn't understand that, don't worry - just return true. </p>
<p class="enddd"></p>
</dd>
</dl>
<p>Okay! We are all set up!</p>
<h1><a class="anchor" id="carrier_expert_payload_phase"></a>
The index, payload, and ack stage</h1>
<p>The methods we've defined so far are sufficient to get through setting up a connection to use our new carrier, and switching our input/output stream implementation if needed. Now, we just need to push any data we are asked to transmit.</p>
<p>One note: we've talked about an INITIATOR and a RECIPIENT carrier, based on who started the connection. After our carriers exchange payload data, you should not assume that the carriers retain the same identity. YARP reserves the right to switch around which carrier is the initiator (there is a port-level command to do this). However, you can assume that there is always exactly one initiator.</p>
<p>When it comes time to send/receive payload data, YARP will call one of the following commands:</p>
<dl>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#a084328aa460dc7aac909cf3cb0d5f7c8" title="Write a message.">yarp::os::Carrier::write</a> (INITIATOR) </dt>
<dd><p class="startdd">Here, you are given the usual "proto" protocol object, and an extra <a class="el" href="classyarp_1_1os_1_1SizedWriter.html" title="Minimal requirements for an efficient Writer.">yarp::os::SizedWriter</a> object that knows about the size of what is to be sent, and also its content.</p>
<p class="interdd">Note: historically, the write operation was broken down into an index phase first, with yarp::os::Carrier::sendIndex. You still have to define that method, but it can do nothing. The write method is guaranteed to be called first.</p>
<p class="interdd">The last act of the write method should call in turn the write method on the SizedWriter object, passing the output stream associated with the protocol object. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ac30068b63b452ecfc18c8932388ff800" title="Expect a message header, if there is one for this carrier.">yarp::os::Carrier::expectIndex</a> (RECIPIENT) </dt>
<dd><p class="startdd">On the receiving side, this method should wait for a message to arrive. If you wrote the message with some kind of header, you could go ahead and consume that now.</p>
<p class="interdd">After expectIndex, YARP will do one or a series of reads from the input stream associated with the protocol object to acquire the actual payload. You are not responsible for that, unlike on the writing side - there is a small asymmetry here. </p>
<p class="enddd"></p>
</dd>
</dl>
<p>Ok, at this point user data has been transmitted! Note that if you want to transform how user data itself is expressed, you need to do that with a custom InputStream/OutputStream class.</p>
<p>If your carrier will send/expect acknowledgements of data transmission, you should define the following two methods appropriately - otherwise they should do nothing:</p>
<dl>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#afc1f917c275b69b59f04229d5f9c92dd" title="Send an acknowledgement, if needed for this carrier.">yarp::os::Carrier::sendAck</a> (RECIPIENT) </dt>
<dd><p class="startdd">Prepare and send an acknowledgement message to the output stream associated with the protocol object. </p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classyarp_1_1os_1_1Carrier.html#ac48549429fd1433a2781e5c57d54eb7a" title="Receive an acknowledgement, if expected for this carrier.">yarp::os::Carrier::expectAck</a> (INITIATOR) </dt>
<dd><p class="startdd">Wait for and read an acknowledgement message from the input stream associated with the protocol object. </p>
<p class="enddd"></p>
</dd>
</dl>
<p>At this point, YARP will call write/expectIndex methods again, and we loop.</p>
<h1><a class="anchor" id="carrier_expert_packets"></a>
An important detail: packets</h1>
<p>YARP divides transmitted data into logical packets. If your streams encounter a non-disastrous failure while sending data, they are expected to have a mechanism for skipping to the next logical packet. Your streams are informed about packet boundaries through the startPacket/endPacket methods.</p>
<p>If your streams are connection-based, you can ignore this, but if they are connectionless then it is important. Take a look at the UDP/MCAST streams (<a class="el" href="classyarp_1_1os_1_1impl_1_1DgramTwoWayStream.html" title="A stream abstraction for datagram communication.">yarp::os::impl::DgramTwoWayStream</a>) implementation, and the DgramTwoWayStreamTest.cpp regression tests.</p>
<h1><a class="anchor" id="carrier_export_complete"></a>
A complete example</h1>
<p>Here's code to create a completely new carrier called "human". It relies on a human reading information on one terminal and typing it on another (see example/carrier/carrier_human.cpp).</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
</div>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006-2019 Istituto Italiano di Tecnologia (IIT)</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006-2010 RobotCub Consortium</span></div>
<div class="line"><span class="comment"> * All rights reserved.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This software may be modified and distributed under the terms of the</span></div>
<div class="line"><span class="comment"> * BSD-3-Clause license. See the accompanying LICENSE file for details.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="libYARP__OS_2include_2yarp_2os_2all_8h.html">yarp/os/all.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carrier_8h.html">yarp/os/Carrier.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Carriers_8h.html">yarp/os/Carriers.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Bytes_8h.html">yarp/os/Bytes.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ManagedBytes_8h.html">yarp/os/ManagedBytes.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="NetType_8h.html">yarp/os/NetType.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Protocol_8h.html">yarp/os/impl/Protocol.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classHumanStream.html">HumanStream</a> : <span class="keyword">public</span> <a class="code" href="classyarp_1_1os_1_1TwoWayStream.html">yarp::os::TwoWayStream</a>, <span class="keyword">public</span> <a class="code" href="classyarp_1_1os_1_1InputStream.html">yarp::os::InputStream</a>, <span class="keyword">public</span> <a class="code" href="classyarp_1_1os_1_1OutputStream.html">yarp::os::OutputStream</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> interrupting;</div>
<div class="line">    <span class="keywordtype">bool</span> needInterrupt;</div>
<div class="line">    std::string inputCache;</div>
<div class="line">    std::string outputCache;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classHumanStream.html#aea43bde465c478ab3fecb7f99b636ab8">HumanStream</a>() {</div>
<div class="line">        interrupting = <span class="keyword">false</span>;</div>
<div class="line">        needInterrupt = <span class="keyword">false</span>;</div>
<div class="line">        inputCache = outputCache = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#aa71c06482c7f95c74191b1e7ea364e65">close</a>() {</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Bye bye&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanStream.html#af4946eb2185ae13869a1bf05027c7366">isOk</a>() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#ae512eab740defe571a7571c2737146ea">interrupt</a>() {</div>
<div class="line">        interrupting = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">while</span> (needInterrupt) {</div>
<div class="line">            <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;*** INTERRUPT: Please hit enter ***&quot;</span>;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;10 &amp;&amp; needInterrupt; i++) {</div>
<div class="line">                <a class="code" href="namespaceyarp_1_1os_1_1Time.html#aca80809e0597551745954e2547e581ee">yarp::os::Time::delay</a>(0.1);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// InputStream</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceyarp_1_1conf.html#a3df5afb43ff7b7cc2b4e3cb9150eab20">ssize_t</a> <a class="code" href="classyarp_1_1os_1_1InputStream.html#a448b29e1cd20c5ae3bf3a43ba6b49f17">read</a>(<a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a>&amp; b) {</div>
<div class="line">        <span class="keywordflow">if</span> (interrupting) { <span class="keywordflow">return</span> -1; }</div>
<div class="line">        <span class="keywordflow">while</span> (inputCache.size() &lt; b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>()) {</div>
<div class="line">            <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt;<span class="stringliteral">&quot;*** CHECK OTHER TERMINAL FOR SOMETHING TO TYPE:&quot;</span>;</div>
<div class="line">            <span class="keywordtype">char</span> buf[1000];</div>
<div class="line">            needInterrupt = <span class="keyword">true</span>;  <span class="comment">// should be mutexed, in real implementation</span></div>
<div class="line">            std::cin.getline(buf,1000);</div>
<div class="line">            needInterrupt = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (interrupting) { <span class="keywordflow">return</span> -1; }</div>
<div class="line">            inputCache += buf;</div>
<div class="line">            inputCache += <span class="stringliteral">&quot;\r\n&quot;</span>;</div>
<div class="line">            <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Thank you&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        memcpy(b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#ad62e722069297651d9efb5fa7fba1d92">get</a>(),inputCache.c_str(),b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>());</div>
<div class="line">        inputCache = inputCache.substr(b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>());</div>
<div class="line">        <span class="keywordflow">return</span> b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// OutputStream</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#a293863b44fee5b21f6eb1515f3b1cfea">write</a>(<span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a>&amp; b) {</div>
<div class="line">        outputCache.append(b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#ad62e722069297651d9efb5fa7fba1d92">get</a>(),b.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>());</div>
<div class="line">        <span class="keywordflow">while</span> (outputCache.find(<span class="stringliteral">&quot;\n&quot;</span>)!=std::string::npos) {</div>
<div class="line">            <span class="keywordtype">size_t</span> idx = outputCache.find(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">            std::string show;</div>
<div class="line">            show.append(outputCache.c_str(),idx);</div>
<div class="line">            <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;*** TYPE THIS ON THE OTHER TERMINAL: &quot;</span> &lt;&lt; show;</div>
<div class="line">            outputCache = outputCache.substr(idx+1);</div>
<div class="line">            <a class="code" href="namespaceyarp_1_1os_1_1Time.html#aca80809e0597551745954e2547e581ee">yarp::os::Time::delay</a>(1);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TwoWayStream</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="classyarp_1_1os_1_1InputStream.html#aa76c86b53f016984cf52bed6e039e9c0">InputStream</a>&amp; <a class="code" href="classHumanStream.html#a68796d805350960c861070f2a327a157">getInputStream</a>() {</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> OutputStream&amp; <a class="code" href="classHumanStream.html#a459a3e94aaffec6e1ebb5dc3280bf1eb">getOutputStream</a>() {</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Contact.html">yarp::os::Contact</a>&amp; <a class="code" href="classHumanStream.html#ac1c9608e3aec1ee4a8eec68b4732bf13">getLocalAddress</a>() {</div>
<div class="line">        <span class="comment">// left undefined</span></div>
<div class="line">        <span class="keywordflow">return</span> local;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Contact.html">yarp::os::Contact</a>&amp; <a class="code" href="classHumanStream.html#a9fe4701c019c9ab4e123ff202c8a98df">getRemoteAddress</a>() {</div>
<div class="line">        <span class="comment">// left undefined</span></div>
<div class="line">        <span class="keywordflow">return</span> remote;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#a8ae552fece9ccc3ba63a80c6607bba14">reset</a>() {</div>
<div class="line">        inputCache = outputCache = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Stream reset&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#a84d0d888eb2c4de7924460830fc54ab4">beginPacket</a>() {</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Packet begins&quot;</span>;</div>
<div class="line">        inputCache = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        outputCache = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanStream.html#a549f48bdc344a30bc9cdf2f3c441865c">endPacket</a>() {</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Packet ends&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Contact.html">yarp::os::Contact</a> local, remote;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classHumanCarrier.html">HumanCarrier</a> : <span class="keyword">public</span> <a class="code" href="classyarp_1_1os_1_1Carrier.html">yarp::os::Carrier</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// First, the easy bits...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="classyarp_1_1os_1_1Carrier.html">yarp::os::Carrier</a> *<a class="code" href="classHumanCarrier.html#a37eecc47ed71629dc41c89260e46bff9">create</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classHumanCarrier.html">HumanCarrier</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code" href="classHumanCarrier.html#a025a8ad7f0815b331b817ad266e78ef5">getName</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;human&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a70f1cc1ab7f06e545862831820eca4ca">isConnectionless</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a057c2597e98aeb8baef45cb718d01ccb">canAccept</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#abbb3637549e7383159bb37de9585cbb5">canOffer</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#aca0aeb91bb0a3abbca7fa1a714d066e7">isTextMode</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">// let&#39;s be text mode, for human-friendliness</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a0921db120393bfe533b486cac404b8bf">canEscape</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#adc7ee2ff6fb5221163ebd8845d86f315">requireAck</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#add6a3c814fbc114859c1a009f4586cef">supportReply</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a87f48bcee517d758f870fdfe3df0da57">isLocal</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code" href="classHumanCarrier.html#ad809eb9098e3e541e2362a86dd4aaf81">toString</a>()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;humans are handy&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanCarrier.html#a7e2f60e665c7c251d57bf7d98aec5558">getHeader</a>(<span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a>&amp; header) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *target = <span class="stringliteral">&quot;HUMANITY&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8 &amp;&amp; i&lt;header.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>(); i++) {</div>
<div class="line">            header.<a class="code" href="classyarp_1_1os_1_1Bytes.html#ad62e722069297651d9efb5fa7fba1d92">get</a>()[i] = target[i];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a41fdb65b1d0175f03dc9cf41b95d19b3">checkHeader</a>(<span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a>&amp; header) {</div>
<div class="line">        <span class="keywordflow">if</span> (header.<a class="code" href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">length</a>()!=8) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *target = <span class="stringliteral">&quot;HUMANITY&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (header.<a class="code" href="classyarp_1_1os_1_1Bytes.html#ad62e722069297651d9efb5fa7fba1d92">get</a>()[i] != target[i]) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classHumanCarrier.html#a2bfd289d565d725aac109ad2273c6e49">setParameters</a>(<span class="keyword">const</span> <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a>&amp; header) {</div>
<div class="line">        <span class="comment">// no parameters - no carrier variants</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now, the initial hand-shaking</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#afa3f28cfac6c24d1234d6f180242295e">prepareSend</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// nothing special to do</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a8f4b5a1c4ee755ed126c61b729eaa751">sendHeader</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// Send the &quot;magic number&quot; for this carrier</span></div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1ManagedBytes.html">yarp::os::ManagedBytes</a> header(8);</div>
<div class="line">        <a class="code" href="classHumanCarrier.html#a7e2f60e665c7c251d57bf7d98aec5558">getHeader</a>(header.bytes());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(header.bytes());</div>
<div class="line">        <span class="keywordflow">if</span> (!proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a88ed49f557bdce2d130810bebc62af31">isOk</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now we can do whatever we want, as long as somehow</span></div>
<div class="line">        <span class="comment">// we also send the name of the originating port</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// let&#39;s just send the port name in plain text terminated with a</span></div>
<div class="line">        <span class="comment">// carriage-return / line-feed</span></div>
<div class="line">        std::string from = proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#a47543e44a05f7508d3db1069ce3f67f9">getRoute</a>().<a class="code" href="classyarp_1_1os_1_1Route.html#a9beaa65ef1683ab12367720e2e98d0f8">getFromName</a>();</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a> b2((<span class="keywordtype">char</span>*)from.c_str(),from.length());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(b2);</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(<span class="charliteral">&#39;\r&#39;</span>);</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(<span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a36ab9b168185c63a46c4b8bd70205e97">flush</a>();</div>
<div class="line">        <span class="keywordflow">return</span> proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a88ed49f557bdce2d130810bebc62af31">isOk</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#aa4a46fa46ec2939be31ac452d5ecda55">expectSenderSpecifier</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// interpret everything that sendHeader wrote</span></div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#af34d20d32c88cfdb80fc9b288a244161">setRoute</a>(proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#a47543e44a05f7508d3db1069ce3f67f9">getRoute</a>().addFromName(proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a9fd557d1748ee4b40c95896441ee93d0">readLine</a>()));</div>
<div class="line">        <span class="keywordflow">return</span> proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a0892111c6a5924504fabb33e8e7bb022">isOk</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#aaf5b9ba77889e65cf2dd0b8fb300261b">expectExtraHeader</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// interpret any extra header information sent - optional</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a011d79099a2a43564db6d2947364ff32">respondToHeader</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// SWITCH TO NEW STREAM TYPE</span></div>
<div class="line">        <a class="code" href="classHumanStream.html">HumanStream</a> *stream = <span class="keyword">new</span> <a class="code" href="classHumanStream.html">HumanStream</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (stream==NULL) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ac552ef35e1a421b84064ca6f287be022">takeStreams</a>(stream);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a98120eaa1fb185818a6baa038f18a72e">expectReplyToHeader</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        <span class="comment">// SWITCH TO NEW STREAM TYPE</span></div>
<div class="line">        <a class="code" href="classHumanStream.html">HumanStream</a> *stream = <span class="keyword">new</span> <a class="code" href="classHumanStream.html">HumanStream</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (stream==NULL) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ac552ef35e1a421b84064ca6f287be022">takeStreams</a>(stream);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a8da359925071fe5924067069aabb994d">isActive</a>() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Payload time!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a7eb477333909d5338085ccfbb2cb483f">write</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto, <a class="code" href="classyarp_1_1os_1_1SizedWriter.html">yarp::os::SizedWriter</a>&amp; writer) {</div>
<div class="line">        <span class="keywordtype">bool</span> ok = <a class="code" href="classHumanCarrier.html#acc1227c0cfc641c15af232cc591c6d0f">sendIndex</a>(proto);</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        writer.<a class="code" href="classyarp_1_1os_1_1SizedWriter.html#a4db70d4d5efadafbcba7b0103053988b">write</a>(proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>());</div>
<div class="line">        <span class="keywordflow">return</span> proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a88ed49f557bdce2d130810bebc62af31">isOk</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#acc1227c0cfc641c15af232cc591c6d0f">sendIndex</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        std::string prefix = <span class="stringliteral">&quot;human says &quot;</span>;</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a> b2((<span class="keywordtype">char</span>*)prefix.c_str(),prefix.length());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(b2);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a0794c0228580181ba2093697251d6ce8">expectIndex</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        std::string prefix = <span class="stringliteral">&quot;human says &quot;</span>;</div>
<div class="line">        std::string compare = prefix;</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a> b2((<span class="keywordtype">char</span>*)prefix.c_str(),prefix.length());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a448b29e1cd20c5ae3bf3a43ba6b49f17">read</a>(b2);</div>
<div class="line">        <span class="keywordtype">bool</span> ok = proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a0892111c6a5924504fabb33e8e7bb022">isOk</a>() &amp;&amp; (prefix==compare);</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;YOU DID NOT SAY &#39;human says &#39;&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> ok;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Acknowledgements, we don&#39;t do them</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#ac36ca0ffb45c9b974fa47d20909e1db1">sendAck</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        std::string prefix = <span class="stringliteral">&quot;computers rule!\r\n&quot;</span>;</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a> b2((<span class="keywordtype">char</span>*)prefix.c_str(),prefix.length());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">os</a>().<a class="code" href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">write</a>(b2);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classHumanCarrier.html#a687210dd95910fc97f4e9382d7ebe740">expectAck</a>(<a class="code" href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a>&amp; proto) {</div>
<div class="line">        std::string prefix = <span class="stringliteral">&quot;computers rule!\r\n&quot;</span>;</div>
<div class="line">        std::string compare = prefix;</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a> b2((<span class="keywordtype">char</span>*)prefix.c_str(),prefix.length());</div>
<div class="line">        proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a448b29e1cd20c5ae3bf3a43ba6b49f17">read</a>(b2);</div>
<div class="line">        <span class="keywordtype">bool</span> ok = proto.<a class="code" href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">is</a>().<a class="code" href="classyarp_1_1os_1_1InputStream.html#a0892111c6a5924504fabb33e8e7bb022">isOk</a>() &amp;&amp; (prefix==compare);</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;YOU DID NOT SAY &#39;computers rule!&#39;&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> ok;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Network.html">yarp::os::Network</a> <a class="code" href="namespaceyarp.html">yarp</a>;</div>
<div class="line">    <a class="code" href="classyarp_1_1os_1_1Carriers.html#a884ca38817eac84393e8f4ecf5b5f0f3">yarp::os::Carriers::addCarrierPrototype</a>(<span class="keyword">new</span> <a class="code" href="classHumanCarrier.html">HumanCarrier</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (argc&lt;2) {</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Please run in two terminals as:\n&quot;</span>;</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;  carrier_human --server\n&quot;</span>;</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;  carrier_human --client\n&quot;</span>;</div>
<div class="line">        std::exit(1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string mode = argv[1];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (mode == <span class="stringliteral">&quot;--server&quot;</span>) {</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Port.html">yarp::os::Port</a> out;</div>
<div class="line">        out.<a class="code" href="classyarp_1_1os_1_1Port.html#adbca981deeed5f66b3c4465b91eac509">open</a>(<span class="stringliteral">&quot;/test/out&quot;</span>);</div>
<div class="line">        <span class="keywordtype">bool</span> connected = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">while</span> (!connected) {</div>
<div class="line">            connected = <a class="code" href="classyarp_1_1os_1_1NetworkBase.html#a20d1100e9e9056164290a5e98e7a651d">yarp::os::Network::connect</a>(<span class="stringliteral">&quot;/test/out&quot;</span>,<span class="stringliteral">&quot;/test/in&quot;</span>,<span class="stringliteral">&quot;human&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (!connected) <a class="code" href="namespaceyarp_1_1os_1_1Time.html#aca80809e0597551745954e2547e581ee">yarp::os::Time::delay</a>(1);</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a> bot;</div>
<div class="line">        bot.<a class="code" href="classyarp_1_1os_1_1Bottle.html#a388ffac14da35ebecd8f78b642c7221b">fromString</a>(<span class="stringliteral">&quot;1 2 3&quot;</span>);</div>
<div class="line">        out.<a class="code" href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">write</a>(bot);</div>
<div class="line">        out.<a class="code" href="classyarp_1_1os_1_1Port.html#ad0c3a032e49f56fbdfc8ca67f3ee2dff">close</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (mode == <span class="stringliteral">&quot;--client&quot;</span>) {</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Port.html">yarp::os::Port</a> in;</div>
<div class="line">        in.<a class="code" href="classyarp_1_1os_1_1Port.html#adbca981deeed5f66b3c4465b91eac509">open</a>(<span class="stringliteral">&quot;/test/in&quot;</span>);</div>
<div class="line">        <a class="code" href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a> bot;</div>
<div class="line">        in.<a class="code" href="classyarp_1_1os_1_1Port.html#a7b4eb018faba3837d50fffee0ea722ef">read</a>(bot);</div>
<div class="line">        <a class="code" href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a>() &lt;&lt; <span class="stringliteral">&quot;Got message &quot;</span> &lt;&lt; bot.<a class="code" href="classyarp_1_1os_1_1Bottle.html#ad8cb921bd7e22d6fcafc3a61db65e75c">toString</a>().c_str();</div>
<div class="line">        in.<a class="code" href="classyarp_1_1os_1_1Port.html#ad0c3a032e49f56fbdfc8ca67f3ee2dff">close</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --><p>Here's how the carrier works.</p>
<p>In one terminal we run the test program as a "client" that will sit and wait for a message: </p><pre class="fragment">./carrier_human --client
</pre><p> Here's what we see: </p><pre class="fragment">yarp: Port /test/in active at tcp://192.168.1.3:10002
</pre><p>Now in another terminal we run the test program as a "server" that will connect to the client and then try to send it the message "1 2 3": </p><pre class="fragment">./carrier_human --server
</pre><p> Here's what we see: </p><pre class="fragment">yarp: Port /test/out active at tcp://192.168.1.3:10012
yarp: Sending output from /test/out to /test/in using human
Packet begins
*** TYPE THIS ON THE OTHER TERMINAL: human says do
*** TYPE THIS ON THE OTHER TERMINAL: 1 2 3
Packet ends
*** CHECK OTHER TERMINAL FOR SOMETHING TO TYPE:
</pre><p>And on the client side here's what we see: </p><pre class="fragment">yarp: Receiving input from /test/out to /test/in using human
Packet begins
*** CHECK OTHER TERMINAL FOR SOMETHING TO TYPE:
</pre><p>What has happened is that the server has made a connection to the client, and then switched over to using our "human" protocol for transmitting data. This protocol relies on reading and writing instructions to the console for a human to follow. If we follow those instructions exactly, and in order, the program will successfully complete just as for any other carrier. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_ad0c3a032e49f56fbdfc8ca67f3ee2dff"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#ad0c3a032e49f56fbdfc8ca67f3ee2dff">yarp::os::Port::close</a></div><div class="ttdeci">void close() override</div><div class="ttdoc">Stop port activity.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00349">Port.cpp:349</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Carriers_html_a884ca38817eac84393e8f4ecf5b5f0f3"><div class="ttname"><a href="classyarp_1_1os_1_1Carriers.html#a884ca38817eac84393e8f4ecf5b5f0f3">yarp::os::Carriers::addCarrierPrototype</a></div><div class="ttdeci">static bool addCarrierPrototype(Carrier *carrier)</div><div class="ttdoc">Add a new connection type.</div><div class="ttdef"><b>Definition:</b> <a href="Carriers_8cpp_source.html#l00302">Carriers.cpp:302</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1TwoWayStream_html"><div class="ttname"><a href="classyarp_1_1os_1_1TwoWayStream.html">yarp::os::TwoWayStream</a></div><div class="ttdoc">A stream which can be asked to perform bidirectional communication.</div><div class="ttdef"><b>Definition:</b> <a href="TwoWayStream_8h_source.html#l00028">TwoWayStream.h:29</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a41fdb65b1d0175f03dc9cf41b95d19b3"><div class="ttname"><a href="classHumanCarrier.html#a41fdb65b1d0175f03dc9cf41b95d19b3">HumanCarrier::checkHeader</a></div><div class="ttdeci">bool checkHeader(const Bytes &amp;header) override</div><div class="ttdoc">Given the first 8 bytes received on a connection, decide if this is the right carrier type to use for...</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00072">HumanCarrier.h:72</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bottle_html"><div class="ttname"><a href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a></div><div class="ttdoc">A simple collection of objects that can be described and transmitted in a portable way.</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8h_source.html#l00072">Bottle.h:73</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_ac36ca0ffb45c9b974fa47d20909e1db1"><div class="ttname"><a href="classHumanCarrier.html#ac36ca0ffb45c9b974fa47d20909e1db1">HumanCarrier::sendAck</a></div><div class="ttdeci">bool sendAck(ConnectionState &amp;proto) override</div><div class="ttdoc">Send an acknowledgement, if needed for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00161">HumanCarrier.h:161</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a057c2597e98aeb8baef45cb718d01ccb"><div class="ttname"><a href="classHumanCarrier.html#a057c2597e98aeb8baef45cb718d01ccb">HumanCarrier::canAccept</a></div><div class="ttdeci">bool canAccept() const override</div><div class="ttdoc">Check if reading is implemented for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00032">HumanCarrier.h:32</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bottle_html_ad8cb921bd7e22d6fcafc3a61db65e75c"><div class="ttname"><a href="classyarp_1_1os_1_1Bottle.html#ad8cb921bd7e22d6fcafc3a61db65e75c">yarp::os::Bottle::toString</a></div><div class="ttdeci">std::string toString() const override</div><div class="ttdoc">Gives a human-readable textual representation of the bottle.</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8cpp_source.html#l00193">Bottle.cpp:193</a></div></div>
<div class="ttc" id="aNetwork_8h_html"><div class="ttname"><a href="Network_8h.html">Network.h</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_aa4a46fa46ec2939be31ac452d5ecda55"><div class="ttname"><a href="classHumanCarrier.html#aa4a46fa46ec2939be31ac452d5ecda55">HumanCarrier::expectSenderSpecifier</a></div><div class="ttdeci">bool expectSenderSpecifier(ConnectionState &amp;proto) override</div><div class="ttdoc">Expect the name of the sending port.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00099">HumanCarrier.h:99</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Carrier_html"><div class="ttname"><a href="classyarp_1_1os_1_1Carrier.html">yarp::os::Carrier</a></div><div class="ttdoc">A base class for connection types (tcp, mcast, shmem, ...) which are called carriers in YARP.</div><div class="ttdef"><b>Definition:</b> <a href="Carrier_8h_source.html#l00047">Carrier.h:48</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a8ae552fece9ccc3ba63a80c6607bba14"><div class="ttname"><a href="classHumanStream.html#a8ae552fece9ccc3ba63a80c6607bba14">HumanStream::reset</a></div><div class="ttdeci">void reset() override</div><div class="ttdoc">Reset the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00085">HumanStream.h:85</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_ad88d8d901b29e3776281b943a4f47596"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">yarp::os::BufferedPort::read</a></div><div class="ttdeci">T * read(bool shouldWait=true) override</div><div class="ttdoc">Read an available object from the port.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00154">BufferedPort-inl.h:154</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1OutputStream_html_a9ee2201aa922c1124392aeb97849148c"><div class="ttname"><a href="classyarp_1_1os_1_1OutputStream.html#a9ee2201aa922c1124392aeb97849148c">yarp::os::OutputStream::write</a></div><div class="ttdeci">virtual void write(char ch)</div><div class="ttdoc">Write a single byte to the stream.</div><div class="ttdef"><b>Definition:</b> <a href="OutputStream_8cpp_source.html#l00017">OutputStream.cpp:17</a></div></div>
<div class="ttc" id="aclassHumanStream_html_ac1c9608e3aec1ee4a8eec68b4732bf13"><div class="ttname"><a href="classHumanStream.html#ac1c9608e3aec1ee4a8eec68b4732bf13">HumanStream::getLocalAddress</a></div><div class="ttdeci">const yarp::os::Contact &amp; getLocalAddress() const override</div><div class="ttdoc">Get the address of the local side of the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00075">HumanStream.h:75</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a84d0d888eb2c4de7924460830fc54ab4"><div class="ttname"><a href="classHumanStream.html#a84d0d888eb2c4de7924460830fc54ab4">HumanStream::beginPacket</a></div><div class="ttdeci">void beginPacket() override</div><div class="ttdoc">Mark the beginning of a logical packet.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00090">HumanStream.h:90</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html"><div class="ttname"><a href="classHumanCarrier.html">HumanCarrier</a></div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00015">HumanCarrier.h:15</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1OutputStream_html"><div class="ttname"><a href="classyarp_1_1os_1_1OutputStream.html">yarp::os::OutputStream</a></div><div class="ttdoc">Simple specification of the minimum functions needed from output streams.</div><div class="ttdef"><b>Definition:</b> <a href="OutputStream_8h_source.html#l00024">OutputStream.h:25</a></div></div>
<div class="ttc" id="aOutputStream_8h_html"><div class="ttname"><a href="OutputStream_8h.html">OutputStream.h</a></div></div>
<div class="ttc" id="ayarpros_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="yarpros_8cpp_source.html#l00227">yarpros.cpp:227</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a7e2f60e665c7c251d57bf7d98aec5558"><div class="ttname"><a href="classHumanCarrier.html#a7e2f60e665c7c251d57bf7d98aec5558">HumanCarrier::getHeader</a></div><div class="ttdeci">void getHeader(Bytes &amp;header) const override</div><div class="ttdoc">Provide 8 bytes describing this connection sufficiently to allow the other side of a connection to se...</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00065">HumanCarrier.h:65</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1InputStream_html_aa76c86b53f016984cf52bed6e039e9c0"><div class="ttname"><a href="classyarp_1_1os_1_1InputStream.html#aa76c86b53f016984cf52bed6e039e9c0">yarp::os::InputStream::InputStream</a></div><div class="ttdeci">InputStream()</div><div class="ttdoc">Constructor.</div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bottle_html_a388ffac14da35ebecd8f78b642c7221b"><div class="ttname"><a href="classyarp_1_1os_1_1Bottle.html#a388ffac14da35ebecd8f78b642c7221b">yarp::os::Bottle::fromString</a></div><div class="ttdeci">void fromString(const std::string &amp;text)</div><div class="ttdoc">Initializes bottle from a string.</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8cpp_source.html#l00186">Bottle.cpp:186</a></div></div>
<div class="ttc" id="aCarriers_8h_html"><div class="ttname"><a href="Carriers_8h.html">Carriers.h</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_adbca981deeed5f66b3c4465b91eac509"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#adbca981deeed5f66b3c4465b91eac509">yarp::os::Port::open</a></div><div class="ttdeci">bool open(const std::string &amp;name) override</div><div class="ttdoc">Start port operation, with a specific name, with automatically-chosen network parameters.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00078">Port.cpp:78</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1SizedWriter_html_a4db70d4d5efadafbcba7b0103053988b"><div class="ttname"><a href="classyarp_1_1os_1_1SizedWriter.html#a4db70d4d5efadafbcba7b0103053988b">yarp::os::SizedWriter::write</a></div><div class="ttdeci">virtual void write(OutputStream &amp;os)</div><div class="ttdef"><b>Definition:</b> <a href="SizedWriter_8cpp_source.html#l00019">SizedWriter.cpp:19</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_acc1227c0cfc641c15af232cc591c6d0f"><div class="ttname"><a href="classHumanCarrier.html#acc1227c0cfc641c15af232cc591c6d0f">HumanCarrier::sendIndex</a></div><div class="ttdeci">virtual bool sendIndex(ConnectionState &amp;proto, SizedWriter &amp;writer)</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00142">HumanCarrier.h:142</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a9fe4701c019c9ab4e123ff202c8a98df"><div class="ttname"><a href="classHumanStream.html#a9fe4701c019c9ab4e123ff202c8a98df">HumanStream::getRemoteAddress</a></div><div class="ttdeci">const yarp::os::Contact &amp; getRemoteAddress() const override</div><div class="ttdoc">Get the address of the remote side of the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00080">HumanStream.h:80</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a0921db120393bfe533b486cac404b8bf"><div class="ttname"><a href="classHumanCarrier.html#a0921db120393bfe533b486cac404b8bf">HumanCarrier::canEscape</a></div><div class="ttdeci">bool canEscape() const override</div><div class="ttdoc">Check if carrier can encode administrative messages, as opposed to just user data.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00045">HumanCarrier.h:45</a></div></div>
<div class="ttc" id="aTextCarrier_8h_html"><div class="ttname"><a href="TextCarrier_8h.html">TextCarrier.h</a></div></div>
<div class="ttc" id="aTwoWayStream_8h_html"><div class="ttname"><a href="TwoWayStream_8h.html">TwoWayStream.h</a></div></div>
<div class="ttc" id="aLog_8h_html_a52c3dab24cf55da2806a5c6e5f5d3b55"><div class="ttname"><a href="Log_8h.html#a52c3dab24cf55da2806a5c6e5f5d3b55">yInfo</a></div><div class="ttdeci">#define yInfo</div><div class="ttdef"><b>Definition:</b> <a href="Log_8h_source.html#l00107">Log.h:107</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a7eb477333909d5338085ccfbb2cb483f"><div class="ttname"><a href="classHumanCarrier.html#a7eb477333909d5338085ccfbb2cb483f">HumanCarrier::write</a></div><div class="ttdeci">bool write(ConnectionState &amp;proto, SizedWriter &amp;writer) override</div><div class="ttdoc">Write a message.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00135">HumanCarrier.h:135</a></div></div>
<div class="ttc" id="aProtocol_8h_html"><div class="ttname"><a href="Protocol_8h.html">Protocol.h</a></div></div>
<div class="ttc" id="aNetType_8h_html"><div class="ttname"><a href="NetType_8h.html">NetType.h</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_adc7ee2ff6fb5221163ebd8845d86f315"><div class="ttname"><a href="classHumanCarrier.html#adc7ee2ff6fb5221163ebd8845d86f315">HumanCarrier::requireAck</a></div><div class="ttdeci">bool requireAck() const override</div><div class="ttdoc">Check if carrier has flow control, requiring sent messages to be acknowledged by recipient.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00049">HumanCarrier.h:49</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_af79f22ea0a51e1e6262a13ed83227b66"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66">yarp::os::BufferedPort::prepare</a></div><div class="ttdeci">T &amp; prepare()</div><div class="ttdoc">Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00114">BufferedPort-inl.h:114</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html">yarp::os::Port</a></div><div class="ttdoc">A mini-server for network communication.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8h_source.html#l00049">Port.h:50</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt; yarp::os::Bottle &gt;</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a2bfd289d565d725aac109ad2273c6e49"><div class="ttname"><a href="classHumanCarrier.html#a2bfd289d565d725aac109ad2273c6e49">HumanCarrier::setParameters</a></div><div class="ttdeci">void setParameters(const Bytes &amp;header) override</div><div class="ttdoc">Configure this carrier based on the first 8 bytes of the connection.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00085">HumanCarrier.h:85</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html_ac552ef35e1a421b84064ca6f287be022"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html#ac552ef35e1a421b84064ca6f287be022">yarp::os::ConnectionState::takeStreams</a></div><div class="ttdeci">virtual void takeStreams(TwoWayStream *streams)=0</div><div class="ttdoc">Provide streams to be used with the connection.</div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html_aee31bb2bfc02862ffcedeccf84ece140"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html#aee31bb2bfc02862ffcedeccf84ece140">yarp::os::ConnectionState::os</a></div><div class="ttdeci">OutputStream &amp; os()</div><div class="ttdoc">Shorthand for getOutputStream()</div><div class="ttdef"><b>Definition:</b> <a href="ConnectionState_8h_source.html#l00123">ConnectionState.h:123</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html_a47543e44a05f7508d3db1069ce3f67f9"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html#a47543e44a05f7508d3db1069ce3f67f9">yarp::os::ConnectionState::getRoute</a></div><div class="ttdeci">virtual const Route &amp; getRoute() const =0</div><div class="ttdoc">Get the route associated with this connection.</div></div>
<div class="ttc" id="aManagedBytes_8h_html"><div class="ttname"><a href="ManagedBytes_8h.html">ManagedBytes.h</a></div></div>
<div class="ttc" id="aclassHumanStream_html"><div class="ttname"><a href="classHumanStream.html">HumanStream</a></div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00023">HumanStream.h:26</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ManagedBytes_html"><div class="ttname"><a href="classyarp_1_1os_1_1ManagedBytes.html">yarp::os::ManagedBytes</a></div><div class="ttdoc">An abstraction for a block of bytes, with optional responsibility for allocating/destroying that bloc...</div><div class="ttdef"><b>Definition:</b> <a href="ManagedBytes_8h_source.html#l00024">ManagedBytes.h:25</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a37eecc47ed71629dc41c89260e46bff9"><div class="ttname"><a href="classHumanCarrier.html#a37eecc47ed71629dc41c89260e46bff9">HumanCarrier::create</a></div><div class="ttdeci">Carrier * create() const override</div><div class="ttdoc">Factory method.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00020">HumanCarrier.h:20</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_add6a3c814fbc114859c1a009f4586cef"><div class="ttname"><a href="classHumanCarrier.html#add6a3c814fbc114859c1a009f4586cef">HumanCarrier::supportReply</a></div><div class="ttdeci">bool supportReply() const override</div><div class="ttdoc">This flag is used by YARP to determine whether the connection can carry RPC traffic,...</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00053">HumanCarrier.h:53</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bytes_html_ad62e722069297651d9efb5fa7fba1d92"><div class="ttname"><a href="classyarp_1_1os_1_1Bytes.html#ad62e722069297651d9efb5fa7fba1d92">yarp::os::Bytes::get</a></div><div class="ttdeci">const char * get() const</div><div class="ttdef"><b>Definition:</b> <a href="Bytes_8cpp_source.html#l00030">Bytes.cpp:30</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html_af34d20d32c88cfdb80fc9b288a244161"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html#af34d20d32c88cfdb80fc9b288a244161">yarp::os::ConnectionState::setRoute</a></div><div class="ttdeci">virtual void setRoute(const Route &amp;route)=0</div><div class="ttdoc">Set the route associated with this connection.</div></div>
<div class="ttc" id="aclassHumanCarrier_html_a025a8ad7f0815b331b817ad266e78ef5"><div class="ttname"><a href="classHumanCarrier.html#a025a8ad7f0815b331b817ad266e78ef5">HumanCarrier::getName</a></div><div class="ttdeci">std::string getName() const override</div><div class="ttdoc">Get the name of this connection type (&quot;tcp&quot;, &quot;mcast&quot;, &quot;shmem&quot;, ...)</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00024">HumanCarrier.h:24</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bytes_html_a1777bdec41bab120b74bc353e3570377"><div class="ttname"><a href="classyarp_1_1os_1_1Bytes.html#a1777bdec41bab120b74bc353e3570377">yarp::os::Bytes::length</a></div><div class="ttdeci">size_t length() const</div><div class="ttdef"><b>Definition:</b> <a href="Bytes_8cpp_source.html#l00025">Bytes.cpp:25</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1NetworkBase_html_a20d1100e9e9056164290a5e98e7a651d"><div class="ttname"><a href="classyarp_1_1os_1_1NetworkBase.html#a20d1100e9e9056164290a5e98e7a651d">yarp::os::NetworkBase::connect</a></div><div class="ttdeci">static bool connect(const std::string &amp;src, const std::string &amp;dest, const std::string &amp;carrier=&quot;&quot;, bool quiet=true)</div><div class="ttdoc">Request that an output port connect to an input port.</div><div class="ttdef"><b>Definition:</b> <a href="Network_8cpp_source.html#l00615">Network.cpp:615</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_a938b0e335554aa0e7fb1d919e51a665f"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#a938b0e335554aa0e7fb1d919e51a665f">yarp::os::BufferedPort::open</a></div><div class="ttdeci">bool open(const std::string &amp;name) override</div><div class="ttdoc">Start port operation, with a specific name, with automatically-chosen network parameters.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00041">BufferedPort-inl.h:41</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1conf_html_a3df5afb43ff7b7cc2b4e3cb9150eab20"><div class="ttname"><a href="namespaceyarp_1_1conf.html#a3df5afb43ff7b7cc2b4e3cb9150eab20">yarp::conf::ssize_t</a></div><div class="ttdeci">::ssize_t ssize_t</div><div class="ttdef"><b>Definition:</b> <a href="numeric_8h_source.html#l00060">numeric.h:60</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1InputStream_html_a9fd557d1748ee4b40c95896441ee93d0"><div class="ttname"><a href="classyarp_1_1os_1_1InputStream.html#a9fd557d1748ee4b40c95896441ee93d0">yarp::os::InputStream::readLine</a></div><div class="ttdeci">std::string readLine(const char terminal='\n', bool *success=nullptr)</div><div class="ttdoc">Read a block of text terminated with a specific marker (or EOF).</div><div class="ttdef"><b>Definition:</b> <a href="InputStream_8cpp_source.html#l00057">InputStream.cpp:57</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1OutputStream_html_a36ab9b168185c63a46c4b8bd70205e97"><div class="ttname"><a href="classyarp_1_1os_1_1OutputStream.html#a36ab9b168185c63a46c4b8bd70205e97">yarp::os::OutputStream::flush</a></div><div class="ttdeci">virtual void flush()</div><div class="ttdoc">Make sure all pending write operations are finished.</div><div class="ttdef"><b>Definition:</b> <a href="OutputStream_8cpp_source.html#l00028">OutputStream.cpp:28</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a549f48bdc344a30bc9cdf2f3c441865c"><div class="ttname"><a href="classHumanStream.html#a549f48bdc344a30bc9cdf2f3c441865c">HumanStream::endPacket</a></div><div class="ttdeci">void endPacket() override</div><div class="ttdoc">Mark the end of a logical packet (see beginPacket).</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00096">HumanStream.h:96</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a70f1cc1ab7f06e545862831820eca4ca"><div class="ttname"><a href="classHumanCarrier.html#a70f1cc1ab7f06e545862831820eca4ca">HumanCarrier::isConnectionless</a></div><div class="ttdeci">bool isConnectionless() const override</div><div class="ttdoc">Check if this carrier is connectionless (like udp, mcast) or connection based (like tcp).</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00028">HumanCarrier.h:28</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a0794c0228580181ba2093697251d6ce8"><div class="ttname"><a href="classHumanCarrier.html#a0794c0228580181ba2093697251d6ce8">HumanCarrier::expectIndex</a></div><div class="ttdeci">bool expectIndex(ConnectionState &amp;proto) override</div><div class="ttdoc">Expect a message header, if there is one for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00149">HumanCarrier.h:149</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1InputStream_html_a0892111c6a5924504fabb33e8e7bb022"><div class="ttname"><a href="classyarp_1_1os_1_1InputStream.html#a0892111c6a5924504fabb33e8e7bb022">yarp::os::InputStream::isOk</a></div><div class="ttdeci">virtual bool isOk() const =0</div><div class="ttdoc">Check if the stream is ok or in an error state.</div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bytes_html"><div class="ttname"><a href="classyarp_1_1os_1_1Bytes.html">yarp::os::Bytes</a></div><div class="ttdoc">A simple abstraction for a block of bytes.</div><div class="ttdef"><b>Definition:</b> <a href="Bytes_8h_source.html#l00027">Bytes.h:28</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1impl_1_1TextCarrier_html_aee9473305c5be07d1ad7c0a5f380ccb8"><div class="ttname"><a href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#aee9473305c5be07d1ad7c0a5f380ccb8">yarp::os::impl::TextCarrier::getSpecifierName</a></div><div class="ttdeci">virtual std::string getSpecifierName() const</div><div class="ttdef"><b>Definition:</b> <a href="TextCarrier_8cpp_source.html#l00033">TextCarrier.cpp:33</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a68796d805350960c861070f2a327a157"><div class="ttname"><a href="classHumanStream.html#a68796d805350960c861070f2a327a157">HumanStream::getInputStream</a></div><div class="ttdeci">InputStream &amp; getInputStream() override</div><div class="ttdoc">Get an InputStream to read from.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00067">HumanStream.h:67</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_a7b4eb018faba3837d50fffee0ea722ef"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#a7b4eb018faba3837d50fffee0ea722ef">yarp::os::Port::read</a></div><div class="ttdeci">bool read(PortReader &amp;reader, bool willReply=false) override</div><div class="ttdoc">Read an object from the port.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00469">Port.cpp:469</a></div></div>
<div class="ttc" id="aclassHumanStream_html_af4946eb2185ae13869a1bf05027c7366"><div class="ttname"><a href="classHumanStream.html#af4946eb2185ae13869a1bf05027c7366">HumanStream::isOk</a></div><div class="ttdeci">bool isOk() const override</div><div class="ttdoc">Check if the stream is ok or in an error state.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00043">HumanStream.h:43</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_aaf5b9ba77889e65cf2dd0b8fb300261b"><div class="ttname"><a href="classHumanCarrier.html#aaf5b9ba77889e65cf2dd0b8fb300261b">HumanCarrier::expectExtraHeader</a></div><div class="ttdeci">bool expectExtraHeader(ConnectionState &amp;proto) override</div><div class="ttdoc">Receive any carrier-specific header.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00107">HumanCarrier.h:107</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html">yarp::os::ConnectionState</a></div><div class="ttdoc">The basic state of a connection - route, streams in use, etc.</div><div class="ttdef"><b>Definition:</b> <a href="ConnectionState_8h_source.html#l00031">ConnectionState.h:32</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1OutputStream_html_a88ed49f557bdce2d130810bebc62af31"><div class="ttname"><a href="classyarp_1_1os_1_1OutputStream.html#a88ed49f557bdce2d130810bebc62af31">yarp::os::OutputStream::isOk</a></div><div class="ttdeci">virtual bool isOk() const =0</div><div class="ttdoc">Check if the stream is ok or in an error state.</div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_a1b49511d808f5731e2f7cf9e9831ff5e"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">yarp::os::Port::write</a></div><div class="ttdeci">bool write(const PortWriter &amp;writer, const PortWriter *callback=nullptr) const override</div><div class="ttdoc">Write an object to the port.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00422">Port.cpp:422</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a8da359925071fe5924067069aabb994d"><div class="ttname"><a href="classHumanCarrier.html#a8da359925071fe5924067069aabb994d">HumanCarrier::isActive</a></div><div class="ttdeci">bool isActive() const override</div><div class="ttdoc">Check if carrier is alive and error free.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00128">HumanCarrier.h:128</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1impl_1_1TextCarrier_html"><div class="ttname"><a href="classyarp_1_1os_1_1impl_1_1TextCarrier.html">yarp::os::impl::TextCarrier</a></div><div class="ttdoc">Communicating between two ports via a plain-text protocol.</div><div class="ttdef"><b>Definition:</b> <a href="TextCarrier_8h_source.html#l00022">TextCarrier.h:23</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_af24f1371b310763572aa7f22459fd71d"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d">yarp::os::BufferedPort::write</a></div><div class="ttdeci">void write(bool forceStrict=false)</div><div class="ttdoc">Write the current object being returned by BufferedPort::prepare.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00126">BufferedPort-inl.h:126</a></div></div>
<div class="ttc" id="aCarrier_8h_html"><div class="ttname"><a href="Carrier_8h.html">Carrier.h</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1InputStream_html_a448b29e1cd20c5ae3bf3a43ba6b49f17"><div class="ttname"><a href="classyarp_1_1os_1_1InputStream.html#a448b29e1cd20c5ae3bf3a43ba6b49f17">yarp::os::InputStream::read</a></div><div class="ttdeci">virtual int read()</div><div class="ttdoc">Read and return a single byte.</div><div class="ttdef"><b>Definition:</b> <a href="InputStream_8cpp_source.html#l00023">InputStream.cpp:23</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1os_html"><div class="ttname"><a href="namespaceyarp_1_1os.html">yarp::os</a></div><div class="ttdoc">An interface to the operating system, including Port based communication.</div><div class="ttdef"><b>Definition:</b> <a href="AbstractCarrier_8h_source.html#l00017">AbstractCarrier.h:17</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a011d79099a2a43564db6d2947364ff32"><div class="ttname"><a href="classHumanCarrier.html#a011d79099a2a43564db6d2947364ff32">HumanCarrier::respondToHeader</a></div><div class="ttdeci">bool respondToHeader(ConnectionState &amp;proto) override</div><div class="ttdoc">Respond to the header.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00112">HumanCarrier.h:112</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Network_html"><div class="ttname"><a href="classyarp_1_1os_1_1Network.html">yarp::os::Network</a></div><div class="ttdoc">Utilities for manipulating the YARP network, including initialization and shutdown.</div><div class="ttdef"><b>Definition:</b> <a href="Network_8h_source.html#l00717">Network.h:718</a></div></div>
<div class="ttc" id="anamespaceyarp_html"><div class="ttname"><a href="namespaceyarp.html">yarp</a></div><div class="ttdoc">The main, catch-all namespace for YARP.</div><div class="ttdef"><b>Definition:</b> <a href="numeric_8h_source.html#l00047">numeric.h:47</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a8f4b5a1c4ee755ed126c61b729eaa751"><div class="ttname"><a href="classHumanCarrier.html#a8f4b5a1c4ee755ed126c61b729eaa751">HumanCarrier::sendHeader</a></div><div class="ttdeci">bool sendHeader(ConnectionState &amp;proto) override</div><div class="ttdoc">Write a header appropriate to the carrier to the connection, followed by any carrier-specific data.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8cpp_source.html#l00013">HumanCarrier.cpp:13</a></div></div>
<div class="ttc" id="aBytes_8h_html"><div class="ttname"><a href="Bytes_8h.html">Bytes.h</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1ConnectionState_html_ae5bc55a55a1038c23603c4e287781213"><div class="ttname"><a href="classyarp_1_1os_1_1ConnectionState.html#ae5bc55a55a1038c23603c4e287781213">yarp::os::ConnectionState::is</a></div><div class="ttdeci">InputStream &amp; is()</div><div class="ttdoc">Shorthand for getInputStream()</div><div class="ttdef"><b>Definition:</b> <a href="ConnectionState_8h_source.html#l00131">ConnectionState.h:131</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a87f48bcee517d758f870fdfe3df0da57"><div class="ttname"><a href="classHumanCarrier.html#a87f48bcee517d758f870fdfe3df0da57">HumanCarrier::isLocal</a></div><div class="ttdeci">bool isLocal() const override</div><div class="ttdoc">Check if carrier operates within a single process.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00057">HumanCarrier.h:57</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_a63c41364f3bf71d1ce68165a28f53998"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#a63c41364f3bf71d1ce68165a28f53998">yarp::os::BufferedPort::close</a></div><div class="ttdeci">void close() override</div><div class="ttdoc">Stop port activity.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00073">BufferedPort-inl.h:73</a></div></div>
<div class="ttc" id="aclassHumanStream_html_ae512eab740defe571a7571c2737146ea"><div class="ttname"><a href="classHumanStream.html#ae512eab740defe571a7571c2737146ea">HumanStream::interrupt</a></div><div class="ttdeci">void interrupt() override</div><div class="ttdoc">Interrupt the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00047">HumanStream.h:47</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Contact_html"><div class="ttname"><a href="classyarp_1_1os_1_1Contact.html">yarp::os::Contact</a></div><div class="ttdoc">Represents how to reach a part of a YARP network.</div><div class="ttdef"><b>Definition:</b> <a href="Contact_8h_source.html#l00038">Contact.h:39</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_abbb3637549e7383159bb37de9585cbb5"><div class="ttname"><a href="classHumanCarrier.html#abbb3637549e7383159bb37de9585cbb5">HumanCarrier::canOffer</a></div><div class="ttdeci">bool canOffer() const override</div><div class="ttdoc">Check if writing is implemented for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00036">HumanCarrier.h:36</a></div></div>
<div class="ttc" id="aInputStream_8h_html"><div class="ttname"><a href="InputStream_8h.html">InputStream.h</a></div></div>
<div class="ttc" id="alibYARP__OS_2include_2yarp_2os_2all_8h_html"><div class="ttname"><a href="libYARP__OS_2include_2yarp_2os_2all_8h.html">all.h</a></div></div>
<div class="ttc" id="aclassHumanStream_html_aea43bde465c478ab3fecb7f99b636ab8"><div class="ttname"><a href="classHumanStream.html#aea43bde465c478ab3fecb7f99b636ab8">HumanStream::HumanStream</a></div><div class="ttdeci">HumanStream()</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00033">HumanStream.h:33</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_ad809eb9098e3e541e2362a86dd4aaf81"><div class="ttname"><a href="classHumanCarrier.html#ad809eb9098e3e541e2362a86dd4aaf81">HumanCarrier::toString</a></div><div class="ttdeci">std::string toString() const override</div><div class="ttdoc">Get name of carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00061">HumanCarrier.h:61</a></div></div>
<div class="ttc" id="aContact_8h_html"><div class="ttname"><a href="Contact_8h.html">Contact.h</a></div></div>
<div class="ttc" id="aclassHumanStream_html_aa71c06482c7f95c74191b1e7ea364e65"><div class="ttname"><a href="classHumanStream.html#aa71c06482c7f95c74191b1e7ea364e65">HumanStream::close</a></div><div class="ttdeci">void close() override</div><div class="ttdoc">Terminate the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00039">HumanStream.h:39</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Route_html_a9beaa65ef1683ab12367720e2e98d0f8"><div class="ttname"><a href="classyarp_1_1os_1_1Route.html#a9beaa65ef1683ab12367720e2e98d0f8">yarp::os::Route::getFromName</a></div><div class="ttdeci">const std::string &amp; getFromName() const</div><div class="ttdoc">Get the source of the route.</div><div class="ttdef"><b>Definition:</b> <a href="Route_8cpp_source.html#l00096">Route.cpp:96</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a293863b44fee5b21f6eb1515f3b1cfea"><div class="ttname"><a href="classHumanStream.html#a293863b44fee5b21f6eb1515f3b1cfea">HumanStream::write</a></div><div class="ttdeci">void write(const Bytes &amp;b) override</div><div class="ttdoc">Write a block of bytes to the stream.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8cpp_source.html#l00033">HumanStream.cpp:33</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_aca0aeb91bb0a3abbca7fa1a714d066e7"><div class="ttname"><a href="classHumanCarrier.html#aca0aeb91bb0a3abbca7fa1a714d066e7">HumanCarrier::isTextMode</a></div><div class="ttdeci">bool isTextMode() const override</div><div class="ttdoc">Check if carrier is textual in nature.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00040">HumanCarrier.h:40</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1InputStream_html"><div class="ttname"><a href="classyarp_1_1os_1_1InputStream.html">yarp::os::InputStream</a></div><div class="ttdoc">Simple specification of the minimum functions needed from input streams.</div><div class="ttdef"><b>Definition:</b> <a href="InputStream_8h_source.html#l00028">InputStream.h:29</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1os_1_1impl_html"><div class="ttname"><a href="namespaceyarp_1_1os_1_1impl.html">yarp::os::impl</a></div><div class="ttdoc">The components from which ports and connections are built.</div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1impl_1_1TextCarrier_html_a0400099ff767f18e971c739846bb8844"><div class="ttname"><a href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#a0400099ff767f18e971c739846bb8844">yarp::os::impl::TextCarrier::getName</a></div><div class="ttdeci">std::string getName() const override</div><div class="ttdoc">Get the name of this connection type (&quot;tcp&quot;, &quot;mcast&quot;, &quot;shmem&quot;, ...)</div><div class="ttdef"><b>Definition:</b> <a href="TextCarrier_8cpp_source.html#l00025">TextCarrier.cpp:25</a></div></div>
<div class="ttc" id="anamespaceyarp_1_1os_1_1Time_html_aca80809e0597551745954e2547e581ee"><div class="ttname"><a href="namespaceyarp_1_1os_1_1Time.html#aca80809e0597551745954e2547e581ee">yarp::os::Time::delay</a></div><div class="ttdeci">void delay(double seconds)</div><div class="ttdoc">Wait for a certain number of seconds.</div><div class="ttdef"><b>Definition:</b> <a href="Time_8cpp_source.html#l00111">Time.cpp:111</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1impl_1_1TextCarrier_html_a73ecae4d55d566b257ea457b0d92e13d"><div class="ttname"><a href="classyarp_1_1os_1_1impl_1_1TextCarrier.html#a73ecae4d55d566b257ea457b0d92e13d">yarp::os::impl::TextCarrier::create</a></div><div class="ttdeci">Carrier * create() const override</div><div class="ttdoc">Factory method.</div><div class="ttdef"><b>Definition:</b> <a href="TextCarrier_8cpp_source.html#l00065">TextCarrier.cpp:65</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1SizedWriter_html"><div class="ttname"><a href="classyarp_1_1os_1_1SizedWriter.html">yarp::os::SizedWriter</a></div><div class="ttdoc">Minimal requirements for an efficient Writer.</div><div class="ttdef"><b>Definition:</b> <a href="SizedWriter_8h_source.html#l00035">SizedWriter.h:36</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a98120eaa1fb185818a6baa038f18a72e"><div class="ttname"><a href="classHumanCarrier.html#a98120eaa1fb185818a6baa038f18a72e">HumanCarrier::expectReplyToHeader</a></div><div class="ttdeci">bool expectReplyToHeader(ConnectionState &amp;proto) override</div><div class="ttdoc">Process reply to header, if one is expected for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00120">HumanCarrier.h:120</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_a687210dd95910fc97f4e9382d7ebe740"><div class="ttname"><a href="classHumanCarrier.html#a687210dd95910fc97f4e9382d7ebe740">HumanCarrier::expectAck</a></div><div class="ttdeci">bool expectAck(ConnectionState &amp;proto) override</div><div class="ttdoc">Receive an acknowledgement, if expected for this carrier.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00168">HumanCarrier.h:168</a></div></div>
<div class="ttc" id="aclassHumanCarrier_html_afa3f28cfac6c24d1234d6f180242295e"><div class="ttname"><a href="classHumanCarrier.html#afa3f28cfac6c24d1234d6f180242295e">HumanCarrier::prepareSend</a></div><div class="ttdeci">bool prepareSend(ConnectionState &amp;proto) override</div><div class="ttdoc">Perform any initialization needed before writing on a connection.</div><div class="ttdef"><b>Definition:</b> <a href="HumanCarrier_8h_source.html#l00092">HumanCarrier.h:92</a></div></div>
<div class="ttc" id="aclassHumanStream_html_a459a3e94aaffec6e1ebb5dc3280bf1eb"><div class="ttname"><a href="classHumanStream.html#a459a3e94aaffec6e1ebb5dc3280bf1eb">HumanStream::getOutputStream</a></div><div class="ttdeci">OutputStream &amp; getOutputStream() override</div><div class="ttdoc">Get an OutputStream to write to.</div><div class="ttdef"><b>Definition:</b> <a href="HumanStream_8h_source.html#l00071">HumanStream.h:71</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.2.2</span></li>
    <li class="footer">Generated on Tue Nov 3 2020 16:49:13 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
