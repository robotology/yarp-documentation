<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Port and connection protocols</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.3.3' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('yarp_protocol.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Port and connection protocols </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#yarp_connection_protocol">The connection protocol</a><ul><li class="level2"><a href="#connection_phases">Connection phases</a></li>
<li class="level2"><a href="#carrier_tcp">The &quot;tcp&quot; carrier</a></li>
<li class="level2"><a href="#carrier_udp">The &quot;udp&quot; carrier</a></li>
<li class="level2"><a href="#carrier_mcast">The &quot;mcast&quot; carrier</a></li>
<li class="level2"><a href="#carrier_text">The &quot;text&quot; carrier</a></li>
<li class="level2"><a href="#proto_shmem">The &quot;shmem&quot; carrier</a></li>
<li class="level2"><a href="#carrier_local">The &quot;local&quot; carrier</a></li>
<li class="level2"><a href="#carrier_known">Known protocol specifiers</a></li>
</ul>
</li>
<li class="level1"><a href="#yarp_protocol_port">Port commands</a></li>
<li class="level1"><a href="#yarp_uri">YARP URIs</a></li>
<li class="level1"><a href="#yarp_carriers">Carriers supported</a></li>
<li class="level1"><a href="#note_manually">Manually interacting with ports</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="yarp_connection_protocol"></a>
The connection protocol</h1>
<p>This is the protocol used for a single connection from an output port to an input port. We discuss how this process gets initiated in the next section. At the point of creation of a connection, the following information is needed:</p>
<ul>
<li>An address &ndash; the machine name and socket-port at which the input port is listening.</li>
<li>The name of the input port.</li>
<li>The name of the output port associated with the connection. This name needs to be retained for proper disconnection in some cases. If the connection is not actually associated with a port, but is initiated by an external entity, then the name is not important and should be set to "external" (or any name without a leading slash characher).</li>
</ul>
<h2><a class="anchor" id="connection_phases"></a>
Connection phases</h2>
<p>The connection protocol has several phases &ndash; header, index, and body.</p>
<ul>
<li><b>Initiation phase</b><ul>
<li>We begin once the sender has successfully opened a tcp socket connection to the receiver (assuming that is the carrier it is registered with).</li>
</ul>
</li>
<li><b>Header phase</b><ul>
<li>This phase follows immediately after the initiation phase.</li>
<li>Transmission of protocol specifier<ul>
<li>Sender transmits 8 bytes that identify the carrier that will be used. The header may be used to pass a few flags also.</li>
<li>Receiver expects 8 bytes, and attempts to find a carrier that is consistent with them.</li>
</ul>
</li>
<li>Transmission of sender name<ul>
<li>Sender transmits the name of the output port it is associated with, in a carrier specific way.</li>
<li>Receiver expects the name of the output port, transmitted in a carrier specific way.</li>
</ul>
</li>
<li>Transmission of extra header material<ul>
<li>Sender may transmit extra information, depending on the carrier.</li>
<li>Receiver may expect extra information, depending on the carrier.</li>
</ul>
</li>
</ul>
</li>
<li><b>Header reply phase</b><ul>
<li>This phase follows immediately after the header phase, and concludes the preamble to actual data transmission. After this phase, the two ports are considered connected.</li>
<li>Receiver may transmit some data, depending on the carrier. Receiver then may switch from the initial network protocol used to something else (udp, mcast, etc), again depending on the carrier.</li>
<li>Sender may expect some data, depending on the carrier. Sender then may switch from the initial network protocol used to something else (udp, mcast, etc), again depending on the carrier.</li>
</ul>
</li>
<li><b>Index phase</b><ul>
<li>Sender sends carrier-dependent data describing properties of the payload data to come.</li>
<li>Receiver expects carrier-dependent data describing properties of the payload data to come.</li>
</ul>
</li>
<li><b>Payload data phase</b><ul>
<li>Sender sends carrier-dependent expression of user data (maybe none).</li>
<li>Receiver expects carrier-dependent expression of user data.</li>
</ul>
</li>
<li><b>Acknowledgement phase</b><ul>
<li>Receiver sends carrier-dependent acknowledgement of receipt of payload data (maybe none).</li>
<li>Sender expects carrier-dependent acknowledgement of receipt of payload data (maybe none).</li>
</ul>
</li>
</ul>
<p>This is the basic pattern of YARP communication between ports. Clearly different carriers have a lot of freedom in how they operate.</p>
<h2><a class="anchor" id="carrier_tcp"></a>
The "tcp" carrier</h2>
<ul>
<li><b>Header and header reply</b><ul>
<li>The 8-byte protocol specifier for tcp is: {<code>Y</code> <code>A</code> <code>0xE4</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}. Another possible variant is: {<code>Y</code> <code>A</code> <code>0x64</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}. The first version identifies a connection that sends acknowledgements; the second is for connections that omit acknowledgements.</li>
<li>The sender name is transmitted and expected to be in the following format: a 4 byte integer (little endian) giving the length of port, followed by the port name in characters, followed by the null character.</li>
<li>There is no extra header material for this carrier.</li>
<li>The header reply is as 8 bytes long: {<code>Y</code> <code>A</code> <code>B1</code> <code>B2</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}, where (<code>B1</code>,<code>B2</code>) is a (little-endian) two-byte integer specifying a socket-port number (unused).</li>
<li>After the header reply, there is no switch in network protocol, the initial tcp connection continues to be used.</li>
</ul>
</li>
<li><b>Index, payload, and acknowledgement</b><ul>
<li>The sender transmits 8 bytes: {<code>Y</code> <code>A</code> <code>0x0A</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}. This identifies the length of the "index header" as 10 (<code>0x0A</code>).</li>
<li>The sender transmits 10 bytes: {<code>LEN</code> <code>0x01</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code>}. <code>LEN</code> is the number of blocks of user data need to be sent. This byte-sequence says there are <code>LEN</code> send blocks, 1 reply block expected, and that the sizes will be listed individually next (this odd format is for backward compatibility with older YARP versions).</li>
<li>The sender transmits <code>LEN</code> 4-byte little-endian integers, one for each of the <code>LEN</code> blocks of user data, giving the length of each block.</li>
<li>The sender transmits 4 bytes: {<code>0x00</code> <code>0x00</code> <code>0x00</code> <code>0x00</code>}. This asks for a reply length of 0.</li>
<li>If this is the variant of the tcp carrier that requires acknowledgments, then the receiver sends 8 bytes: {<code>Y</code> <code>A</code> <code>B1</code> <code>B2</code> <code>B3</code> <code>B4</code> <code>R</code> <code>P</code>}, where (<code>B1</code>,<code>B2</code>,<code>B3</code>,<code>B4</code>) is a little-endian integer giving a length (could be 0). It then sends that number of extra bytes.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="carrier_udp"></a>
The "udp" carrier</h2>
<ul>
<li><b>Header and header reply</b><ul>
<li>The 8-byte protocol specifier for udp is: {<code>Y</code> <code>A</code> <code>0x61</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}. The following variant of this should also be accepted: {<code>Y</code> <code>A</code> <code>0xE1</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>} (it is the same thing).</li>
<li>Otherwise header and header reply are identical to the tcp case.</li>
<li>After the header reply, both sides switch to a udp connection to the socket-port specified in the header reply.</li>
</ul>
</li>
<li><b>Index, payload, and acknowledgement</b><ul>
<li>Identical to tcp. Data is split arbitrarily to fit into datagrams. Datagrams have sequence numbers and checksums so that if part of message is lost or corrupted the entire message can be dropped cleanly.</li>
<li>Acknowledgments are not a possibility.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="carrier_mcast"></a>
The "mcast" carrier</h2>
<ul>
<li><b>Header and header reply</b><ul>
<li>The 8-byte protocol specifier for mcast is: {<code>Y</code> <code>A</code> <code>0x62</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>}. The following variant of this should also be accepted: {<code>Y</code> <code>A</code> <code>0xE2</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>} (it is the same thing).</li>
<li>The sender name is sent as for tcp.</li>
<li>Extra header material is send (6 bytes). The first 4 bytes specify a multicast IP address. Next 2 bytes are a (bigendian) integer giving a socket-port number. Note that producing these numbers can be helped by side communication with the name server.</li>
<li>There is no header reply for mcast.</li>
<li>Both sides switch to a multi-cast group on the specified IP and socket-port.</li>
</ul>
</li>
<li><b>Index, payload, and acknowledgement</b><ul>
<li>Identical to udp.</li>
<li>But at most one connection from a given port with an mcast carrier should actually write to the multi-cast group.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="carrier_text"></a>
The "text" carrier</h2>
<ul>
<li>This carrier is carefully designed to make it easy to type into a terminal.</li>
<li><b>Header and header reply</b><ul>
<li>The 8-byte protocol specifier for text is: {<code>C</code> <code>O</code> <code>N</code> <code>N</code> <code>E</code> <code>C</code> <code>T</code> <code>&#160;</code>}.</li>
<li>The sender name is sent as plain text followed by the newline character <code>\n</code>.</li>
<li>There is no extra material.</li>
<li>There is no header reply expected for text.</li>
<li>There is no network protocol switch.</li>
</ul>
</li>
<li><b>Index, payload, and acknowledgement</b><ul>
<li>There is no index.</li>
<li>The payload is expected to be a series of lines of text terminated by the newline character <code>\n</code>.</li>
<li>There is no acknowledgement expected for text.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="proto_shmem"></a>
The "shmem" carrier</h2>
<p>This is essentially the same as the tcp carrier, except that there is no header reply, and there is a shift in protocol after header transmission on both sides to an ACE shared memory stream. This carrier is currently being reworked to make its specification independent of ACE, and to further improve efficiency in an existing implementation.</p>
<p>The advantage of this carrier is that it is fast &ndash; the best way to send messages between processes on a single machine. Of course, it doesn't work for processes on different machines.</p>
<h2><a class="anchor" id="carrier_local"></a>
The "local" carrier</h2>
<p>This carrier is designed specifically for communication between threads in a single process. Giving a specification for the protocol it uses has low priority, since two such threads are unlikely to be using different YARP implementations.</p>
<h2><a class="anchor" id="carrier_known"></a>
Known protocol specifiers</h2>
<p>Here are the currently known protocol specifiers. The "shmem" carrier is not yet documented, but is implemented in the C++ version of YARP.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">8-byte magic number  </th><th class="markdownTableHeadNone">protocol  </th><th class="markdownTableHeadNone">variant   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0x61</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">udp  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0xE1</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">udp  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0x62</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">mcast  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0xE2</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">mcast  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0x63</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">shmem  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0xE3</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">shmem  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0x64</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">tcp  </td><td class="markdownTableBodyNone">without acks   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Y</code> <code>A</code> <code>0xE4</code> <code>0x1E</code> <code>0x00</code> <code>0x00</code> <code>R</code> <code>P</code>  </td><td class="markdownTableBodyNone">tcp  </td><td class="markdownTableBodyNone">with acks   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>C</code> <code>O</code> <code>N</code> <code>N</code> <code>E</code> <code>C</code> <code>T</code> <code>&#160;</code>  </td><td class="markdownTableBodyNone">text  </td><td class="markdownTableBodyNone">without acks   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>C</code> <code>O</code> <code>N</code> <code>N</code> <code>A</code> <code>C</code> <code>K</code> <code>&#160;</code>  </td><td class="markdownTableBodyNone">text  </td><td class="markdownTableBodyNone">with acks   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>L</code> <code>O</code> <code>C</code> <code>A</code> <code>L</code> <code>I</code> <code>T</code> <code>Y</code>  </td><td class="markdownTableBodyNone">local  </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h1><a class="anchor" id="yarp_protocol_port"></a>
Port commands</h1>
<p>Every port is always available for new connections from external entities - to request that new connections between ports be created, old connections be removed, to inquire after status, etc. % The protocol used for communicating with a port is layered on top of the protocol described in the previous section. Any carrier can be used. The "payload data" is as follows:</p>
<ul>
<li>We send an 8 byte header {<code>0x00</code>,<code>0x00</code>,<code>0x00</code>,<code>0x00</code>,<code>~</code>,<code>CHAR</code>,<code>0x00</code>,<code>0x01</code>}.</li>
<li><code>CHAR</code> is a character that identifies what the message is about.</li>
<li><code>CHAR</code> = <code>d</code>: this header is used to signal that user data is arriving next, as opposed to a port command</li>
<li><code>CHAR</code> = anything else: this signals that a port command follows.</li>
</ul>
<p>for the port command case (<code>CHAR</code> = <code>0x00</code>) the remainder of the message is interpreted as a string <code>S</code>.</p>
<ul>
<li><code>S</code> begins with <code>/</code>, e.g. <code>/read</code>: this is a request to add a Connection to the named InputPort.</li>
<li><code>S</code> begins with <code>!</code>, e.g. <code>!/read</code>: this is a request to remove a Connection to the named InputPort.</li>
<li><code>S</code> begins with <code>~, e.g.</code>~/read`: this is a request to remove a Connection from the named OutputPort.</li>
<li><code>S</code> is <code>*</code>: this is a request for the port to dump information about what it is connected to.</li>
<li><code>S</code> is <code>q</code>: the specific connection that the command is received on should now shut down.</li>
<li><code>S</code> is <code>a</code>: this is like <code>d</code>, signalling that data should be expected, but the data will not be passed on to the client of the port. Instead it will be processed internally according to <a class="el" href="port_admin.html">The administrative interface to YARP ports</a>. This is a more user-friendly interface for communicating with a port.</li>
</ul>
<p>Alternatively, with the "text" carrier, we send a string terminated in <code>\n</code>. This is the string <code>S</code>. The first letter is copied to be <code>CHAR</code>.</p>
<h1><a class="anchor" id="yarp_uri"></a>
YARP URIs</h1>
<p>Port names in YARP can contain multiple special elements. We've seen names such as <code>/write</code>. We can also have names such as <code>udp://write</code> which means "connect to the port
named `/write` using the udp carrier".</p>
<p>We can also prepend a network selector of the form <code>/net=NETNAME/</code>. For example, a name such as <code>udp://net=196/write</code> means "connect to the port named <code>/write</code> using the udp carrier, and make the connection on the network with ip addresses beginning with <code>196</code>". This is useful in scenarios with multiple networks, where it may be desirable to route connections through particular networks (for example, to devote a network to time-critical traffic). This functionality is supported primarily with the help of the name server. The ip it reports for a machine is usually a reasonable default, but the user can choose using "net=" to request a name on a particular network.</p>
<p>Symbolic network names can be configured. This process is not yet specified. You can do it right now by setting properties of a fake port called <code>networks</code> (no leading slash), where the properties are symbolic names and their values are the numeric network IP prefix. But this process will change.</p>
<h1><a class="anchor" id="yarp_carriers"></a>
Carriers supported</h1>
<p>An implementation of YARP2 must support at least the "tcp" carrier. Other carriers that may be supported: "text", "udp", "mcast", "shmem", "local".</p>
<p>As a place to start an implementation, the "text" carrier is very simple to implement, and can masquerade as "tcp" for the purposes of initial handshaking.</p>
<p>To see this, get the "netcat" program (available as debian package of the same name). In one terminal, run: </p><pre class="fragment">nc -l -p 9000
</pre><p> This starts a tcp listener on socket-port 9000, and prints out any data that arrives there. Then tell the name server to create an entry for this listener, and tag it as accepting text: </p><pre class="fragment">yarp name register /nc tcp ... 9000
yarp name set /nc accepts text
</pre><p> Now lets write some data to that port. </p><pre class="fragment">yarp write /write text://nc
</pre><p>Type something in, such as "hello world", and hit return. On the terminal running netcat you should see: </p><pre class="fragment">CONNECT /write
d
0 "hello world"
</pre><p> This is what text mode looks like, for the particular data type used by yarp read and write ("bottles"). As we saw in an earlier section, we can also write to ports in text mode. And if we were to restart nc and then try the following: </p><pre class="fragment">yarp connect text://nc /foo
</pre><p> You should see: </p><pre class="fragment">CONNECT external
/foo
</pre><p> This is what a command to connect looks like in YARP2. If we omit the <code>text:/</code> then the tcp carrier may be used, which is compatible with YARP1 but is a bit less trivial to work with. Once our YARP implementations are up to date, the default command carrier will be switched to text.</p>
<h1><a class="anchor" id="note_manually"></a>
Manually interacting with ports</h1>
<p>Suppose we have created ports as follows by typing the following in different terminals: </p><pre class="fragment">  yarp server
  yarp write /write
  yarp read /read
  yarp read /read2
</pre><p>We could connect and disconnect ports using the YARP companion utility, but here's how we could do the same thing "manually":</p>
<pre class="fragment">command:  yarp where
response: Name server is available at ip 192.168.0.3 port 10000

command:  telnet 192.168.0.3 10000
type:     NAME_SERVER query /write
response: registration name /write ip 192.168.0.3 port 10001 type tcp
          *** end of message
          [connection closes]

command:  telnet 192.168.0.3 10001
type:     CONNECT anonymous
response: Welcome anonymous
type:     *
response: This is /write
          There are no outgoing connections
          There is this connection from anonymous to /write using protocol tcp
          *** end of message
type:     /read
response: Connected to /read
type:     *
response: This is /write
          There is a connection from /write to /read using protocol tcp
          There is this connection from anonymous to /write using protocol tcp
          *** end of message
type:     !/read
response: Removing connection from /write to /read
type:     /mcast://read
response: Connected to /read
type:     /read2
response: Connected to /read2
type:     *
response: This is /write
          There is a connection from /write to /read using protocol mcast
          There is a connection from /write to /read2 using protocol tcp
          There is this connection from anonymous to /write using protocol tcp
          *** end of message
type:     q
response: Bye bye
          [connection closes]

command:  telnet 192.168.0.3 10000
type:     NAME_SERVER query /read
response: registration name /write ip 192.168.0.3 port 10002 type tcp
          *** end of message
          [connection closes]

command:  telnet 192.168.0.3 10002
type:     CONNECT anonymous
response: Welcome anonymous
type:     *
response: This is /read
          There are no outgoing connections
          There is a connection from /write to /read using protocol mcast
          There is this connection from anonymous to /read using protocol tcp
          *** end of message
type:     q
response: Bye bye
          [connection closes]
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.3.3</span></li>
    <li class="footer">Generated on Tue Nov 3 2020 16:57:07 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
