<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: The name server protocol</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.4.6' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('name_server.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The name server protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#name_server_port">The name server is just another Port</a></li>
<li class="level1"><a href="#name_server_content">What the name server stores</a></li>
<li class="level1"><a href="#protocol_name_query">query</a></li>
<li class="level1"><a href="#protocol_name_register">register</a></li>
<li class="level1"><a href="#protocol_name_unregister">unregister</a></li>
<li class="level1"><a href="#protocol_name_list">list</a></li>
<li class="level1"><a href="#protocol_name_set">set</a></li>
<li class="level1"><a href="#protocol_name_get">get</a></li>
<li class="level1"><a href="#protocol_name_check">check</a></li>
<li class="level1"><a href="#protocol_name_route">route</a></li>
<li class="level1"><a href="#protocol_name_bot_query">bot query</a></li>
<li class="level1"><a href="#protocol_name_bot_list">bot list</a></li>
<li class="level1"><a href="#name_server_discovery">Finding the name server</a></li>
<li class="level1"><a href="#name_server_namespaces">Name server namespaces</a></li>
<li class="level1"><a href="#name_server_history">An older name server protocol</a></li>
</ul>
</div>
<div class="textblock"><p>The name server is a YARP program that maintains a list of all YARP Ports and how to connect to them.</p>
<p>The name server itself has a YARP Port, usually named "/root". All other YARP programs communicate with the name server through this port. This communication is usually hidden within YARP library calls, but we document it here in order to allow communication with the name server by clients not using the YARP libraries.</p>
<h1><a class="anchor" id="name_server_port"></a>
The name server is just another Port</h1>
<p>Connecting to the name server is just like connecting to any other YARP Port (see <a class="el" href="yarp_protocol.html">Port Protocol</a>). The one problem is that you have to find out where the name server is (what machine, what socket port number) somehow. For other YARP Ports, you can solve that problem by asking the name server, but that option isn't available for the name server itself.</p>
<p>One option is simply to make sure the name server is started on a particular known machine on your lab (say 192.168.0.3) on a known socket port number (say 10000, the default).</p>
<p>The name server itself, once started, records its contact information in a configuration file (you can type "yarp conf" to find out where that file is). Other YARP programs will check this file to see how to reach the name server. If that doesn't work, there is a multicast protocol for discovering the server. This is discussed in <a class="el" href="name_server.html#name_server_discovery">Finding the name server</a>.</p>
<h1><a class="anchor" id="name_server_content"></a>
What the name server stores</h1>
<p>The name server maintains a set of records, whose key is a text string (the name of a Port). The rest of the record contains whatever information is needed to make an initial connection to a given Port; for tcp this is at least a hostname and a socket number. There is also a description of what kinds of connections the port can or is willing to participate in after the initial connection. The set of protocols (called `&lsquo;carrier&rsquo;' in this context) that the port can accept an incoming data connection for are recorded as a set called the `&lsquo;accept&rsquo;' set. The set of carries the port can create an outgoing data connection for are recorded as a set called the the `&lsquo;offer&rsquo;' set.</p>
<p>For example, suppose you want to communicate with a Port called `&lsquo;/write&rsquo;'. The first step is to ask the name server about this Port. The name server runs on a known socket-port of a known machine, listening for tcp connections. It is usually queried through a library call, but for illustration purposes we describe querying it using telnet. Suppose the name server is running on machine 192.168.0.3 and listening on socket-port 10000 (we will discuss a procedure for discovering this information later). Then we can query the name server about the Port /write as follows:</p>
<pre class="fragment">telnet 192.168.0.3 10000
</pre><p>The name server should start listening &ndash; if the connection is refused, something is wrong. Once the connection is made, type:</p>
<pre class="fragment">CONNECT foo
d
query /write
</pre><p>The server will respond with something of the form:</p>
<pre class="fragment">Welcome foo
registration name /write ip 5.255.112.227 port 10001 type tcp
*** end of message
</pre><p>So the Port named /write is listening on the machine with IP address 5.255.112.227, on port 10001, and it expects TCP connections.</p>
<p>How do Ports get registered in the same place? Here's how to create a (fake) registration manually (usually it is of course done through a library call). Telnet to the name server as before, and type:</p>
<pre class="fragment">register /write
</pre><p>The server will respond with something of the form:</p>
<pre class="fragment">registration name /write ip 5.255.112.227 port 10001 type tcp
*** end of message
</pre><p>The name server takes responsibility for allocating socket-ports and identifying the machine the Port runs on.</p>
<p>We now enumerate commands you can send to the name server, and the nature of its response.</p>
<h1><a class="anchor" id="protocol_name_query"></a>
query</h1>
<pre class="fragment">query PORT
</pre><p>Requests registration information for the named port. Response is of the following form: </p><pre class="fragment">registration name PORT ip ADDRESS port NUMBER type CARRIER
*** end of message
</pre><p> For example: </p><pre class="fragment">registration name /write ip 5.255.112.227 port 10001 type tcp
*** end of message
</pre><p> If there is no registration for the port, the registration line is omitted, and instead the response is simply: </p><pre class="fragment">*** end of message
</pre><p>See <a class="el" href="name_server.html#protocol_name_bot_query">bot query</a> for a version of this command that is easier to use in automation.</p>
<h1><a class="anchor" id="protocol_name_register"></a>
register</h1>
<pre class="fragment">register PORT
</pre><p>Requests creation of registration information for the named port. Response is of the following form: </p><pre class="fragment">registration name PORT ip ADDRESS port NUMBER type CARRIER
*** end of message
</pre><p> For example: </p><pre class="fragment">registration name /write ip 5.255.112.227 port 10001 type tcp
*** end of message
</pre><p>Optionally, the user can take responsibility for more, and issue commands in one of the following forms: </p><pre class="fragment">register PORT CARRIER
register PORT CARRIER IP
register PORT CARRIER IP NUMBER
</pre><p> Any value (including the port name) can be replaced by `&lsquo;...&rsquo;' to leave it up to the name-server to choose it. For example: </p><pre class="fragment">register ... tcp 127.0.0.1 8080
</pre><p> Gives something of the form: </p><pre class="fragment">registration name /tmp/port/1 ip 127.0.0.1 port 8080 type tcp
*** end of message
</pre><p> If you choose to set the ip yourself, be careful &ndash; there is the possibility of problems with multiple ways to identify the same machine. It is best to let the name server choose a name, which it should do in a consistent way. If a machine has multiple ip addresses on multiple networks, that can be handled &ndash; see the discussion of the ips property in the section on set. That is important for the purposes of controlling which network is used for connections from one port to another.</p>
<h1><a class="anchor" id="protocol_name_unregister"></a>
unregister</h1>
<pre class="fragment">unregister PORT
</pre><p>Removes registration information for the named port. Response is of the following form: </p><pre class="fragment">*** end of message
</pre><h1><a class="anchor" id="protocol_name_list"></a>
list</h1>
<pre class="fragment">list
</pre><p>Gives registration information of all known ports. Response is of the following form: </p><pre class="fragment">registration name /write ip 130.251.4.159 port 10021 type tcp
registration name /read ip 130.251.4.159 port 10031 type tcp
registration name /tmp/port/4 ip 130.251.4.159 port 10011 type tcp
registration name /tmp/port/3 ip 130.251.4.52 port 10021 type tcp
registration name /tmp/port/2 ip 130.251.4.52 port 10011 type tcp
registration name /tmp/port/1 ip 130.251.4.159 port 10001 type tcp
*** end of message
</pre><p>See <a class="el" href="name_server.html#protocol_name_bot_list">bot list</a> for a version of this command that is easier to use in automation.</p>
<h1><a class="anchor" id="protocol_name_set"></a>
set</h1>
<pre class="fragment">set PORT PROPERTY VALUE1 VALUE2 ...
</pre><p>The name server can store extra properties of a port, beyond the bare details associated with registration. The set command is used to do this. For example, the command: </p><pre class="fragment">set /write offers tcp udp mcast
</pre><p> Gets the following response: </p><pre class="fragment">port /write property offers = tcp udp mcast
</pre><p> The get and check commands can then be used to query such properties.</p>
<p>There are some special properties used by YARP. Property <code>ips'' can list multiple identifiers of a machine. Property</code>offers'' lists carriers that an output port can support. Property `&lsquo;accepts&rsquo;' lists carriers that an input port can support.</p>
<h1><a class="anchor" id="protocol_name_get"></a>
get</h1>
<pre class="fragment">get PORT PROPERTY
</pre><p>Gets the values of a stored property. For example, after the set command example shown earlier, the command: </p><pre class="fragment">get /write offers
</pre><p> Returns the following response: </p><pre class="fragment">port /write property offers = tcp udp mcast
</pre><h1><a class="anchor" id="protocol_name_check"></a>
check</h1>
<pre class="fragment">check PORT PROPERTY VALUE
</pre><p>Checks if a stored property can take the given value. For example, after the set command example shown earlier, the command: </p><pre class="fragment">check /write offers tcp
</pre><p> Returns the following response: </p><pre class="fragment">port /write property offers value tcp present true
</pre><h1><a class="anchor" id="protocol_name_route"></a>
route</h1>
<pre class="fragment">route PORT1 PORT2
</pre><p>Finds a good way to connect an output port to an input port, based on the carriers they have in common (preferred carriers can optionally be added to this command in decreasing order of preference) and which carriers are physically possible (for example, &lsquo;shmem&rsquo; requires ports to be on the same machine, and &lsquo;local&rsquo; requires ports to belong to threads with a shared memory space). For example, the command: </p><pre class="fragment">route /write /read
</pre><p> Returns the following response: </p><pre class="fragment">port /write route /read = shmem://read
</pre><p> Suggesting that shmem is the best carrier to use.</p>
<h1><a class="anchor" id="protocol_name_bot_query"></a>
bot query</h1>
<pre class="fragment">bot query /PORT
</pre><p>Returns information about a port in an easy-to-parse, Bottle-compatible format. Less easy to read for a human, but much better for automation.</p>
<p>The return format is a list with the string "port" as its first item, followed by one sub-list containing a series of key-value pairs. One important key is "name", whose value is the name of the port. If the port requested does not exist, this key will not be present, and instead there will be an error key.</p>
<h1><a class="anchor" id="protocol_name_bot_list"></a>
bot list</h1>
<pre class="fragment">bot list
bot list /PREFIX
</pre><p>Returns a list of ports in an easy-to-parse, Bottle-compatible format. Less easy to read for a human, but much better for automation.</p>
<p>The return format is a list with the string "ports" as its first item, followed by one sub-list for each matching port (if <code>/PREFIX</code> is supplied, this is all ports named <code>/PREFIX</code> or <code>/PREFIX/*</code>; if no prefix is supplied, it is all ports). The sublist contains a series of key-value pairs. One important key is "name", whose value is the name of the port.</p>
<h1><a class="anchor" id="name_server_discovery"></a>
Finding the name server</h1>
<p>For yarp utilities to correctly discover how to contact the name server, there should be a file <code><a class="el" href="namespaceyarp_1_1conf.html">yarp.conf</a></code> in the directory <code>$HOME/.yarp/conf/</code> that looks like this: </p><pre class="fragment">192.168.0.3 10000
</pre><p> This gives the machine and socket-port that the name server is assumed to be running on.</p>
<p>(The name of this file will be different if <a class="el" href="name_server.html#name_server_namespaces">namespaces</a> are in use. You can always determine the name of this file and its expected location by typing <a class="el" href="yarp.html#yarp_conf">yarp conf</a>).</p>
<p>If this file does not exist, or is incorrect, yarp utilities will attempt to contact the nameserver using multi-cast broadcasts to 224.2.1.1 port 10001 (this is a YARP2 feature, not available in YARP1). If the nameserver is running a machine reachable from multi-cast, it will respond with its `&lsquo;true&rsquo;' tcp address, which will then be used by the utility. The configuration file will be updated automatically for future reference. The multi-cast protocol is identical to the normal tcp protocol. Clients can broadcast <code>NAME_SERVER query /root'' to trigger the name server to send a record of the form</code>registration name /root ip ADDRESS port NUMBER type CARRIER''. Multi-cast broadcasts should not generally be used by clients to communicate with the name server, since the output of the name server is not tagged with the recipient, so there is the potential for cross-talk. But for queries like this it is safe.</p>
<h1><a class="anchor" id="name_server_namespaces"></a>
Name server namespaces</h1>
<p>It is sometimes useful to have multiple name servers running on the same network. This is possible, although you have to take some care.</p>
<p>Normally it is a good idea to run just one yarp name server on a given local network. The name server keeps track of resources (such as socket port numbers) available on different machines, and if two name servers are in use, there can be conflicts as each server assigns resources without being aware of the other.</p>
<p>If you are aware of the potential for resource conflict, and take steps to avoid it, it is sometimes useful to run multiple name servers. Here's how.</p>
<p>We've said that the name server is just a Port, with the name "/root". In fact, you can change the Port name you expect a name server to have. The Port name is called the "namespace".</p>
<p>Type: </p><pre class="fragment">  yarp namespace
</pre><p> It will report something like: </p><pre class="fragment">  No namespace specified, using default
  YARP namespace: /root
</pre><p>This means that we expect to use a server called "/root". This is the default. Let's assume there's already a name server running somewhere on your local network. It will be called "/root". Now suppose we want to avoid using that name server, and use one on our own machine temporarily. Pick a name you like, for example "/my/root" and type:</p>
<pre class="fragment">  yarp namespace /my/root
</pre><p>This will report something like:</p>
<pre class="fragment">  Setting namespace in: /home/paulfitz/.yarp/conf/yarp_namespace.conf
  Remove this file to revert to the default namespace (/root)
  YARP namespace: /my/root
</pre><p>All further queries of the form: </p><pre class="fragment">  yarp namespace
</pre><p> report: </p><pre class="fragment">  YARP namespace: /my/root
</pre><p> Typing: </p><pre class="fragment">  yarp where
</pre><p> should fail right now, since the "/root" name server will be ignored, and there is no name server with the name "/my/root" available. Let's rectify that. On your machine, type: </p><pre class="fragment">  yarp server
</pre><p> This will start up a server with the name "/my/root". Now "yarp where" should start working, and if you type: </p><pre class="fragment">  yarp check
</pre><p> it should work, and you should see ports being registered on your personal name server. If it does not work (perhaps you are on a wireless network, or multicast search is failing for some other reason), type "yarp conf" and edit/create the named file in the same way as described in <a class="el" href="name_server.html#name_server_discovery">Finding the name server</a>.</p>
<p>To switch back to using the main name server, type: </p><pre class="fragment">  yarp namespace /root
</pre><p>Be careful switching from one to the other, since names registered in one namespace are not registered in the other.</p>
<p>If you want to simultaneously use both name servers, you'll need to be very careful. At a minimum, you'll want to start up your personal name server to allocate socket port numbers in a different range to the default (10000-): </p><pre class="fragment">  yarp server 20000
</pre><h1><a class="anchor" id="name_server_history"></a>
An older name server protocol</h1>
<p>The name server used to use its own non-standard protocol, rather than the standard Port protocol. This older protocol is still supported. It is very simple: make a tcp connection, and send commands with the string "" prefixed. For example, if we connect to the name server:</p>
<pre class="fragment">telnet 192.168.0.3 10000
</pre><p>And type:</p>
<pre class="fragment">NAME_SERVER query /write
</pre><p>The server will respond with something of the form:</p>
<pre class="fragment">registration name /write ip 5.255.112.227 port 10001 type tcp
*** end of message
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.4.6</span></li>
    <li class="footer">Generated on Sat Jul 3 2021 02:17:08 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
