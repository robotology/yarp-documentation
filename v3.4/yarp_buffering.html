<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Buffering Policies in YARP</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.4.6' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('yarp_buffering.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Buffering Policies in YARP </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#s_buffering_writing">Life-cycle: writing to a port</a></li>
<li class="level1"><a href="#s_buffering_reading">Life-cycle: reading from a port</a></li>
</ul>
</div>
<div class="textblock"><p>This page assumes you are familiar with the use of YARP <code><a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a></code> and <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html" title="A mini-server for performing network communication in the background.">yarp::os::BufferedPort</a></code> objects.</p>
<p>If this is not the case, you may want to go back and have a look at the following pages before you continue:</p>
<ul>
<li><a class="el" href="note_ports.html">Getting Started with YARP Ports</a> </li>
<li><a class="el" href="port_expert.html">Port Power, Going Further with Ports</a></li>
</ul>
<p>Read and write operations with YARP Port are blocking, this means that readers and senders wait for each other ensuring that all messages are transmitted on the network. Notice that this means that YARP itself will not drop messages, if you use a non reliable protocol (like UDP) messages may still be dropped on by the network layer (this may happen frequently on a busy network).</p>
<p>In robotic applications it is often wise to decouple timing before senders and receivers. This is useful, because you want to avoid interference between readers that go at different speeds. At this aim YARP provides a specific type of port called <code>BufferedPort</code>.</p>
<p>In a <code>BufferedPort</code> messages are sent and received in the background without having to stop your processing. This requires a little care to understand the life-cycle of objects written to and read from the network (see <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a></code> and <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d" title="Write the current object being returned by BufferedPort::prepare.">yarp::os::BufferedPort::write()</a></code>).</p>
<p>By default a <code>BufferedPort</code> attempts to reduce latency between senders and receivers. To do so messages may be dropped by the writer if <code><a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a></code> is called too quickly. The reader may also drop messages that arrive between subsequent calls to <code><a class="el" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">BufferedPort::read()</a></code>, this ensures that in slow readers new messages travel with high priority. This policy is sometimes called Oldest Packet Drop (ODP).</p>
<p>If your application cannot afford dropping messages you can change the buffering policy. Use <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#a5b162e30ad21b6c506520c4fde2c7377" title="Write the current object being returned by BufferedPort::prepare, waiting until any previous sends ar...">yarp::os::BufferedPort::writeStrict()</a></code> when writing to a port, this waits for pending transmissions to be finished before writing new data. Call <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aecb5533cb8005f6fe4278d292ec21033" title="Call this to strictly keep all messages, or allow old ones to be quietly dropped.">yarp::os::BufferedPort::setStrict()</a></code> to change the buffering policy to FIFO at the receiver side. In this way all messages will be stored inside the <code>BufferedPort</code> and delivered to the reader. Pay attention that in this case a slow reader may experience increasing latency and that the <code>BufferedPort</code> may allocate memory in the background.</p>
<p>Methods that can be useful to monitor the status of read and write operations are: <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#a94b8c3e80cdf71ed2013a4a839a46c1b" title="Get the number of objects ready to be read.">yarp::os::BufferedPort::getPendingReads()</a></code> and <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aba9a714a20524d9a6da2127d1102c3da" title="Report whether the port is currently writing data.">yarp::os::BufferedPort::isWriting()</a></code>.</p>
<p>It is also important to understand that a <code>BufferedPort</code> is managing the life-cycle of the messages transmitted on the network. This means that the <code>BufferedPort</code> will allocate and re-cycle objects in its internal buffers.</p>
<h1><a class="anchor" id="s_buffering_writing"></a>
Life-cycle: writing to a port</h1>
<p>When you call <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66" title="Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.">yarp::os::BufferedPort::prepare()</a></code> you get a slot from the internal buffer. This slot is reserved for you, until the next call to <code><a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a></code>. This means that you are free to write inside the object returned by <code>BufferedPort::prepare()</code>, until the next call to <code><a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a></code>. At this point the YARP infrastructure will begin transmitting the message and you are no longer allowed to modify it (well, actually nobody forbids doing so, but in this case you may have unexpected effects, i.e. probably the message will be corrupted).</p>
<p>Objects are recycled within the <code>BufferedPort</code> to save CPU cycles, so the next time you call <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66" title="Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.">yarp::os::BufferedPort::prepare()</a></code> you will not get an empty object. Make sure you clean the object before you write to it (for example do not append data to a <code><a class="el" href="classyarp_1_1os_1_1Bottle.html" title="A simple collection of objects that can be described and transmitted in a portable way.">yarp::os::Bottle</a></code>), otherwise you will get unexpected behavior (likely the object will contain past data). This code example illustrates this concept:</p>
<div class="fragment"><div class="line"><a class="code" href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt;yarp::os::Bottle&gt;</a> port;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a>&amp; b = port.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66">prepare</a>();</div>
<div class="line"><span class="comment">// write to b</span></div>
<div class="line">port.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d">write</a>();</div>
<div class="line"><span class="comment">// don&#39;t touch b!</span></div>
<div class="ttc" id="aclassyarp_1_1os_1_1Bottle_html"><div class="ttname"><a href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a></div><div class="ttdoc">A simple collection of objects that can be described and transmitted in a portable way.</div><div class="ttdef"><b>Definition:</b> <a href="Bottle_8h_source.html#l00072">Bottle.h:73</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt; yarp::os::Bottle &gt;</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_af24f1371b310763572aa7f22459fd71d"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d">yarp::os::BufferedPort::write</a></div><div class="ttdeci">void write(bool forceStrict=false)</div><div class="ttdoc">Write the current object being returned by BufferedPort::prepare.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00126">BufferedPort-inl.h:126</a></div></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_af79f22ea0a51e1e6262a13ed83227b66"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66">yarp::os::BufferedPort::prepare</a></div><div class="ttdeci">T &amp; prepare()</div><div class="ttdoc">Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00114">BufferedPort-inl.h:114</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="s_buffering_reading"></a>
Life-cycle: reading from a port</h1>
<p>To read from a <code>BufferedPort</code> you call <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a></code>, this returns a pointer to the message which arrived most recently (or the oldest message in the queue, if you changed the buffering policy to FIFO using <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aecb5533cb8005f6fe4278d292ec21033" title="Call this to strictly keep all messages, or allow old ones to be quietly dropped.">yarp::os::BufferedPort::setStrict()</a></code>). This object is reserved and not touched by YARP, until the next call to <code><a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a></code>. This code example clarify this issue:</p>
<div class="fragment"><div class="line"><a class="code" href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt;yarp::os::Bottle&gt;</a> port;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classyarp_1_1os_1_1Bottle.html">yarp::os::Bottle</a>* b1 = port.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">read</a>();</div>
<div class="line"><span class="comment">// read b1, YARP will not touch it until the next call to read().</span></div>
<div class="line">Bottle* b2 = port.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">read</a>();</div>
<div class="line"><span class="comment">// now read b2, YARP will not touch it until the next call to read().</span></div>
<div class="line"><span class="comment">// The object pointed to by b1 can be re-cycled by YARP to store new data.</span></div>
<div class="line"><span class="comment">// If you access b1 you may get garbage.</span></div>
<div class="ttc" id="aclassyarp_1_1os_1_1BufferedPort_html_ad88d8d901b29e3776281b943a4f47596"><div class="ttname"><a href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">yarp::os::BufferedPort::read</a></div><div class="ttdeci">T * read(bool shouldWait=true) override</div><div class="ttdoc">Read an available object from the port.</div><div class="ttdef"><b>Definition:</b> <a href="BufferedPort-inl_8h_source.html#l00154">BufferedPort-inl.h:154</a></div></div>
</div><!-- fragment --><p>Notice, however, that you never run in troubles if you follow the best practice and access messages in a loop, i.e.:</p>
<div class="fragment"><div class="line"><a class="code" href="classyarp_1_1os_1_1BufferedPort.html">yarp::os::BufferedPort&lt;yarp::os::Bottle&gt;</a> port;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    Bottle *b1=port.<a class="code" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596">read</a>();</div>
<div class="line">    <span class="comment">// It is safe to read b1, YARP will not touch it.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In the code above the scope of <code>b1</code> automatically enforces safe access to the messages. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.4.6</span></li>
    <li class="footer">Generated on Sat Jul 3 2021 02:17:09 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
