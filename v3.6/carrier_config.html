<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Configuring YARP Connections</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.6.0' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('carrier_config.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Configuring YARP Connections </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#carrier_config_tcp">tcp carrier</a></li>
<li class="level1"><a href="#carrier_config_udp">udp carrier</a></li>
<li class="level1"><a href="#carrier_config_mcast">mcast (multicast) carrier</a></li>
<li class="level1"><a href="#carrier_config_shmem">shmem (shared memory) carrier</a></li>
<li class="level1"><a href="#carrier_config_local">local (within-process) carrier</a></li>
<li class="level1"><a href="#carrier_config_text">text (text-mode across tcp) carrier</a></li>
<li class="level1"><a href="#carrier_config_text_ack">text_ack (text-mode across tcp with acknowledgement) carrier</a></li>
<li class="level1"><a href="#carrier_config_fast_tcp">fast_tcp (tcp without acknowledgement) carrier</a></li>
<li class="level1"><a href="#carrier_config_http">http carrier</a></li>
<li class="level1"><a href="#carrier_config_mjpeg">mjpeg (mjpeg-over-http) carrier</a></li>
<li class="level1"><a href="#carrier_config_xmlrpc">xmlrpc carrier</a></li>
<li class="level1"><a href="#carrier_config_tcpros">tcpros carrier</a></li>
<li class="level1"><a href="#carrier_config_bayer">bayer carrier</a></li>
</ul>
</div>
<div class="textblock"><p>Every YARP connection has a specific type of carrier associated with it.</p>
<p>This corresponds roughly to the "transport" used to carry data. For example there is the tcp carrier, the udp carrier, the mcast (multi-cast) carrier. For each transport, there can be several variants of carrier. For example, across tcp, there can be the basic binary-mode tcp carrier, or the text (text-mode) carrier, or the fast_tcp carrier which takes some shortcuts for speed.</p>
<p>Before using carriers other than the default, please do make sure you understand the performance of your network and check that it is configured well - see <a class="el" href="yarp_cluster.html">Setting up your network for YARP</a>.</p>
<p>Here we look at configuration issues that arise for individual carriers.</p>
<ul>
<li><a class="el" href="carrier_config.html#carrier_config_tcp">tcp carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_udp">udp carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_mcast">mcast (multicast) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_shmem">shmem (shared memory) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_local">local (within-process) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_text">text (text-mode across tcp) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_text_ack">text_ack (text-mode across tcp with acknowledgement) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_fast_tcp">fast_tcp (tcp without acknowledgement) carrier</a></li>
<li><a class="el" href="carrier_config.html#carrier_config_http">http carrier</a></li>
</ul>
<p>Optional carriers: </p><ul>
<li><a class="el" href="carrier_config_mpi.html">mpi carriers</a> </li>
<li><a class="el" href="carrier_config.html#carrier_config_mjpeg">mjpeg (mjpeg-over-http) carrier</a> </li>
<li><a class="el" href="carrier_config.html#carrier_config_xmlrpc">xmlrpc carrier</a> </li>
<li><a class="el" href="carrier_config.html#carrier_config_tcpros">tcpros carrier</a> </li>
<li><a class="el" href="carrier_config.html#carrier_config_bayer">bayer carrier</a></li>
</ul>
<h1><a class="anchor" id="carrier_config_tcp"></a>
tcp carrier</h1>
<p>This is the default carrier for YARP connections. It doesn't really need much configuration. For two ports, /src and /dest, you can establish a tcp connection between them by typing: </p><pre class="fragment">yarp connect /src /dest
</pre><p> or equivalently: </p><pre class="fragment">yarp connect /src /dest tcp
</pre><p>If the two ports are on separate computers connected by multiple networks, the network the connection uses may not be the one you'd prefer. If you want to control this, you can prepend "/net=IP-PREFIX/" to the target port name. For example, a name such as "/net=196/write" means "connect to the port named /write using the network with ip addresses beginning with 196''. See <a class="el" href="yarp_protocol.html#yarp_uri">YARP URIs</a>.</p>
<h1><a class="anchor" id="carrier_config_udp"></a>
udp carrier</h1>
<p>You can establish a UDP connection between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest udp
</pre><p>The udp carrier is unreliable (by the nature of the underlying UDP protocol). However, on a local network under controlled conditions UDP can be a very efficient method for moving data.</p>
<p>The udp carrier is unidirectional; it should be used for streaming messages rather than RPC (remote procedure call) send/reply sequences.</p>
<p>YARP will discard messages with corrupted, missing, duplicated, or out-of-order parts, so the only problem you should have is messages simply failing to arrive.</p>
<p>If you have multiple networks, you can control which networks individual connections use with the same method described for the <a class="el" href="carrier_config.html#carrier_config_tcp">tcp carrier</a>.</p>
<p>The steps described in <a class="el" href="yarp_cluster.html">Setting up your network for YARP</a> are very important if you will be sending large YARP messages using udp.</p>
<p>Large messages are broken into a series of datagrams. You can control the size of those datagrams in bytes by setting the environment variable YARP_DGRAM_SIZE (to control both udp and multicast together) or YARP_UDP_SIZE (to control just udp datagram size). The right setting for this number depends a lot on what you want to do. It is worth experimenting across quite a large range, say from 5000 to 120000 or more.</p>
<h1><a class="anchor" id="carrier_config_mcast"></a>
mcast (multicast) carrier</h1>
<p>You can establish a multicast connection between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest mcast
</pre><p>CAREFUL: multicast is not supported by all all network hardware, and even when it is, support can be a bit hit-and-miss.</p>
<p>For multiple ports reading from the same source, YARP will map these logical connections to a single multicasting source.</p>
<p>The mcast carrier is unreliable (by the nature of the underlying multicast protocol). However, on a local network under controlled conditions multicast can be a very efficient method for moving data.</p>
<p>The mcast carrier is unidirectional; it should be used for streaming messages rather than RPC (remote procedure call) send/reply sequences.</p>
<p>YARP will discard messages with corrupted, missing, duplicated, or out-of-order parts, so the only problem you should have is messages simply failing to arrive.</p>
<p>If you have multiple networks, you can control which networks individual connections use with the same method described for the <a class="el" href="carrier_config.html#carrier_config_tcp">tcp carrier</a>.</p>
<p>The steps described in <a class="el" href="yarp_cluster.html">Setting up your network for YARP</a> are very important if you will be sending large YARP messages using mcast.</p>
<p>Large messages are broken into a series of datagrams. You can control the size of those datagrams in bytes by setting the environment variable YARP_DGRAM_SIZE (to control both udp and multicast together) or YARP_MCAST_SIZE (to control just multicast datagram size). The right setting for this number depends a lot on what you want to do. It is worth experimenting across quite a large range, say from 5000 to 120000 or more.</p>
<h1><a class="anchor" id="carrier_config_shmem"></a>
shmem (shared memory) carrier</h1>
<p>You can establish a shared memory connection between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest shmem
</pre><dl class="section note"><dt>Note</dt><dd>Such connections will not work unless the source and destination ports are on the same machine. That is the nature of shared memory.</dd></dl>
<p>The author of this documentation is not aware of any configuration options for this carrier.</p>
<h1><a class="anchor" id="carrier_config_local"></a>
local (within-process) carrier</h1>
<p>You can establish a connection via shared process memory between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest local
</pre><dl class="section note"><dt>Note</dt><dd>Such connections will not work unless the source and destination ports belong to the same process.</dd></dl>
<p>For ports that are in control of message allocation and reuse (i.e. BufferedPort ports), this is a very efficient carrier. The messages held by source and destination ports are placed into a merged pool with zero copies needed.</p>
<h1><a class="anchor" id="carrier_config_text"></a>
text (text-mode across tcp) carrier</h1>
<p>You can establish a text-mode connection between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest text
</pre><p>This is a reliable TCP connection. This is useful if the destination port is not actually a YARP port, but a socket being read by a non-YARP program. Text-mode messages are particularly easy to read (see <a class="el" href="yarp_without_yarp.html">YARP without YARP</a>).</p>
<p>This type of connection does not contain acknowledgements to the sender of data received. If this is a problem, use the <a class="el" href="carrier_config.html#carrier_config_text_ack">text_ack carrier</a>.</p>
<h1><a class="anchor" id="carrier_config_text_ack"></a>
text_ack (text-mode across tcp with acknowledgement) carrier</h1>
<p>You can establish a text-mode connection between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest text_ack
</pre><p>This is a reliable TCP connection. This is useful if the destination port is not actually a YARP port, but a socket being read by a non-YARP program. Text-mode messages are particularly easy to read (see <a class="el" href="yarp_without_yarp.html">YARP without YARP</a>).</p>
<p>This type of connection has acknowledgements to the sender of data received, unlike the <a class="el" href="carrier_config.html#carrier_config_text">text carrier</a>.</p>
<h1><a class="anchor" id="carrier_config_fast_tcp"></a>
fast_tcp (tcp without acknowledgement) carrier</h1>
<p>You can establish a binary-mode tcp connection without acknowledgements between two ports /src and /dest by typing: </p><pre class="fragment">yarp connect /src /dest fast_tcp
</pre><p>This can be useful to get a bit more speed in cases where flow is producer-limited, not consumer-limited. In general though it is safer to use the regular <a class="el" href="carrier_config.html#carrier_config_tcp">tcp carrier</a>.</p>
<h1><a class="anchor" id="carrier_config_http"></a>
http carrier</h1>
<p>This is a carrier for use from web browsers. It is not intended for port-to-port connections. See <a class="el" href="yarp_http.html">YARP ports from your browser</a> for details.</p>
<h1><a class="anchor" id="carrier_config_mjpeg"></a>
mjpeg (mjpeg-over-http) carrier</h1>
<p>This carrier is for transporting images only. It is handy for reading directly from IP cameras, or streaming images to a browser (most modern browsers can directly render mjpeg-over-http streams). See <a class="el" href="yarp_http.html#yarp_http_recv_images">Viewing images in a browser</a>.</p>
<pre class="fragment">yarp connect /src /dest mjpeg
</pre><p>To compile this carrier, turn on YARP_COMPILE_CARRIER_PLUGINS and then ENABLE_yarpcar_mjpeg_carrier in CMake. There will be an extra CMake option called MJPEG_AUTOCOMPRESS. If turned on, this carrier will deliver images of standard YARP image format to ports. If turned off, this carrier will deliver blobs that can be read by <a class="el" href="classyarp_1_1os_1_1ManagedBytes.html" title="An abstraction for a block of bytes, with optional responsibility for allocating/destroying that bloc...">yarp::os::ManagedBytes</a> or <a class="el" href="classyarp_1_1os_1_1Bottle.html" title="A simple collection of objects that can be described and transmitted in a portable way.">yarp::os::Bottle</a>. See yarp::mjpeg::MjpegDecompression for helper functions. The motivation for disabling automatic decompression is to reduce load for clients that need to read images only occasionally.</p>
<h1><a class="anchor" id="carrier_config_xmlrpc"></a>
xmlrpc carrier</h1>
<p>This carrier transmits and receives messages in XMLRPC format.</p>
<pre class="fragment">yarp connect /src /dest local
</pre><p>Messages are automatically converted to and from Bottle-compatible format. Here is the mapping used: </p><ul>
<li>XMLRPC int = Bottle int </li>
<li>XMLRPC string = Bottle string </li>
<li>XMLRPC double = Bottle double </li>
<li>XMLRPC array = Bottle list </li>
<li>XMLRPC struct = Bottle list</li>
</ul>
<p>Both arrays and structures in XMLRPC are mapped to Bottle lists. Structures are mapped to a list with the tag "dict" prepended, followed by sublists with key-value mappings: </p><pre class="fragment">  (dict (key1 val1) (key2 val2))
</pre><p>The <a class="el" href="classyarp_1_1os_1_1Bottle.html" title="A simple collection of objects that can be described and transmitted in a portable way.">yarp::os::Bottle</a> find/findGroup/check methods will work fine on such lists, or you could populate a Property object if you want fast look-up.</p>
<p>If you want to convert a Bottle list that may start with the string "dict" or "list", prepend the keyword "list". </p><pre class="fragment">  (list ...)
</pre><p> That keyword will be silently consumed, and will guarantee that an XMLRPC array is produced.</p>
<p>XMLRPC messages that start with a string may be treated as an administrative message (and not passed on to the client reading from a port) if the initial string is one of the following: </p><ul>
<li>publisherUpdate </li>
<li>requestTopic </li>
<li>getPid </li>
<li>getBusInfo</li>
</ul>
<p>This is for ROS compatibility (see <a class="el" href="yarp_with_ros.html">Using YARP with ROS</a>).</p>
<h1><a class="anchor" id="carrier_config_tcpros"></a>
tcpros carrier</h1>
<p>This carrier is for interoperations with ROS. See <a class="el" href="yarp_with_ros.html">Using YARP with ROS</a> and <a href="http://www.ros.org/wiki/ROS/TCPROS">http://www.ros.org/wiki/ROS/TCPROS</a></p>
<h1><a class="anchor" id="carrier_config_bayer"></a>
bayer carrier</h1>
<p>The bayer carrier converts bayer images to rgb images on the receiver's side of a connection. It is a modifying carrier, and so can be used in combination with other carriers. For example, suppose port /grabber is streaming bayer images. For concreteness, here's a test program to do that (back.ppm is an arbitrary test image in PPM format): </p><pre class="fragment">  yarpdev --device fakeFrameGrabber --src back.ppm --bayer --name /grabber
</pre><p> Suppose we start an image viewer and look at the stream from /grabber, using (for example) udp: </p><pre class="fragment">  yarpview /view
  yarp connect /grabber /view udp
</pre><p> We will see a monochrome, speckled image (a bayer image). We can now reconnect with a connection that is configured to "debayer" the image on the receiver side: </p><pre class="fragment">  yarp connect /grabber /view udp+recv.bayer
</pre><p> We should now see a color image. To use a downsampling debayer algorithm, we can do: </p><pre class="fragment">  yarp connect /grabber /view udp+recv.bayer+size.half
</pre><p> or equivalently: </p><pre class="fragment">  yarp connect /grabber udp+recv.bayer+size.half://view
</pre><p>If we are reading from a source using a non-default bayer color ordering, we can also specify this with the "order" carrier modifier: </p><pre class="fragment">  yarp connect /grabber /view udp+recv.bayer+order.bggr
</pre><p> This says the first pixel on the first row is a blue color, followed by green. On the second row, the first pixel is green, followed by red.</p>
<p>Debayer filters from libdc1394 are supported, and can be specified using the "method" carrier modifier: </p><pre class="fragment">  yarp connect /grabber /view tcp+recv.bayer+method.vng
</pre><p> Available methods: bilinear, hqlinear, downsample, vng, ahd, nearest, simple. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.6.0</span></li>
    <li class="footer">Generated on Wed Jun 1 2022 14:48:30 for YARP by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
