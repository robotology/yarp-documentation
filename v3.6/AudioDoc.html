<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Audio in YARP</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.6.0' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('AudioDoc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Audio in YARP </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="datatype"></a>
yarp::sig::Sound data type</h1>
<p><a class="el" href="classyarp_1_1sig_1_1Sound.html" title="Class for storing sounds See Audio in YARP for additional documentation on YARP audio.">yarp::sig::Sound</a> is a <a class="el" href="classyarp_1_1os_1_1Portable.html" title="This is a base class for objects that can be both read from and be written to the YARP network.">yarp::os::Portable</a> type, which means that can be transmitted/received over the network through a <a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a>. The internal storage currently supports only <b>16-bit audio</b>. The sampling frequency f (in Hz) and the channels number c can be freely chosen by the user. The Sound class behaves like a NxM vector, with N the number of samples and M the number of channels. Each sample ranges from -32768 to 32767 and represents 1/f seconds of audio data.</p>
<p>This matrix representation can be linearized to a plain vector in two different ways: <b>interleaved</b> (recommended) and <b>not-interleaved</b>. Let's consider an example constituted by a two channels sound. Let's call 1,2,3,4 the first four samples of first channel of sound, and A,B,C,D the first four samples of the second channel. The interleaved representation will arrange the samples as 1A2B3C4D. This is representation allows easy sound processing in the time domain (the time increases monotonically) The non-interleaved representation arranges the samples as 1234ABCD. This arrangement is useful when we want to process a specific audio channel only.</p>
<p>Sounds can be read/written to disk via the methods included in <a class="el" href="namespaceyarp_1_1sig_1_1file.html">yarp::sig::file</a> namespace. Read/write methods are implemented for .wav and .mp3 audio formats (<a class="el" href="SoundFile_8h.html">SoundFile.h</a>) Audio can be transmitted over the network <b>uncompressed</b> (default), or with <b>mp3 compression</b> (via sound_compression_mp3 portmonitor, see: Mp3SoundConverter) The <a class="el" href="classyarp_1_1sig_1_1Sound.html" title="Class for storing sounds See Audio in YARP for additional documentation on YARP audio.">yarp::sig::Sound</a> also offer some basic processing functionalities such as <b>amplification</b>, <b>normalization</b>, <b>peak filtering</b>. See <a class="el" href="classyarp_1_1sig_1_1Sound.html" title="Class for storing sounds See Audio in YARP for additional documentation on YARP audio.">yarp::sig::Sound</a> class documentation for additional details.</p>
<h1><a class="anchor" id="devices_general"></a>
yarp devices</h1>
<p>Audio-related devices include <b>physical device drivers</b> and <b>wrapper devices</b> which send/receive sound data over the network.</p>
<h1><a class="anchor" id="driver_devices"></a>
Physical device drivers</h1>
<ul>
<li><a class="el" href="classfakeMicrophone.html" title="fakeMicrophone : fake microphone device implementing the IAudioGrabberSound interface to generate a t...">fakeMicrophone</a> a device which generates a predefined audio tone for testing purposes.</li>
<li><a class="el" href="classfakeSpeaker.html" title="fakeSpeaker : fake device implementing the IAudioRender device interface to play sound">fakeSpeaker</a> a device which receives audio data and consume it (without playing) for testing purposes.</li>
<li><a class="el" href="classaudioFromFileDevice.html" title="audioFromFileDevice : This device driver, wrapped by default by AudioRecorderWrapper,...">audioFromFileDevice</a> a device which reads a audio file from disk and sends it over the network via audioRecorderWrapper.</li>
<li><a class="el" href="classaudioToFileDevice.html" title="audioToFileDevice : This device driver, wrapped by default by AudioPlayerWrapper, is used to save to ...">audioToFileDevice</a> a device which receives audio data and writes it on disk.</li>
<li>portaudioRecorder (<a class="el" href="classPortAudioRecorderDeviceDriver.html" title="portaudioRecorder: A device driver for an audio source wrapped by PortAudio library.">PortAudioRecorderDeviceDriver</a>) a device which records audio from the local hardware using <a href="http://portaudio.com/">portaudio</a> library and sends it over the network via audioRecorderWrapper</li>
<li>portaudioPlayer (<a class="el" href="classPortAudioPlayerDeviceDriver.html" title="portaudioPlayer: A device driver for an audio playback device wrapped by PortAudio library.">PortAudioPlayerDeviceDriver</a>) a device which receives audio data and plays it on the local hardware, using <a href="http://portaudio.com/">portaudio</a> library.</li>
</ul>
<p>All these devices derive from the same base classes <a class="el" href="classyarp_1_1dev_1_1AudioRecorderDeviceBase.html" title="AudioRecorderDeviceBase : a base class for all audio recorder devices">yarp::dev::AudioRecorderDeviceBase</a> and <a class="el" href="classyarp_1_1dev_1_1AudioPlayerDeviceBase.html" title="AudioPlayerDeviceBase : a base class for all audio player devices">yarp::dev::AudioPlayerDeviceBase</a> which are also responsible for parsing configuration parameters which are common for all the physical device drivers. They include: the sampling frequency (<code>AUDIO_BASE::rate</code>), the number of channels (<code>AUDIO_BASE::channels</code>), the hardware volume (<code>AUDIO_BASE::hw_gain</code>) etc.</p>
<p>Important: the <code>AUDIO_BASE::samples</code> parameter requires additional explanation. It controls the size (in samples) of the internal buffer responsible for temporary storing the audio data during the recording/playback. The length of the buffer expressed in seconds is equal to the number of samples multiplied by the parameter <code>AUDIO_BASE::rate</code>. The size of this buffer should be large enough to store the data received by the attached wrapper. For example a playback buffer of 2000 samples is required if the attached audioPlayerWrapper is expected to receive sounds which have a length of 1000 samples maximum (in general we recommend to use a buffer which has twice the size of the received audio sound).</p>
<p>Another important parameter for the devices deriving from <a class="el" href="classyarp_1_1dev_1_1AudioPlayerDeviceBase.html" title="AudioPlayerDeviceBase : a base class for all audio player devices">yarp::dev::AudioPlayerDeviceBase</a> is the playback mode which can be either <code>immediate</code> or <code>append</code>. In the first case, is a new audio is received while the current playback is still in progress, the current playback is interrupt, and the new sound is reproduced. Otherwise, the received Sound is appended in the buffer and will be played after the completion of the current playback (this is the default playback mode) Please note that the appending mode may trigger a buffer overrun if its size in not large enough to contain the appended sounds. In this case, just increasing the value of <code>AUDIO_BASE::samples</code> will be enough to solve the problem, with no particular drawback (except for memory usage).</p>
<h1><a class="anchor" id="devices_wrappers"></a>
wrapper devices</h1>
<ul>
<li><a class="el" href="classAudioPlayerWrapper.html" title="AudioPlayerWrapper: A Wrapper which receives audio streams from a network port and sends it to device...">AudioPlayerWrapper</a> is used to receive data from the network on yarp port and play it locally on a playback device. It uses the <a class="el" href="classyarp_1_1dev_1_1IAudioRender.html">yarp::dev::IAudioRender</a> to control the attached device.</li>
<li><a class="el" href="classAudioRecorderWrapper.html" title="AudioRecorderWrapper: A Wrapper which streams audio over the network, after grabbing it from a device">AudioRecorderWrapper</a> is used to record audio from a local device and send data to the network via yarp port. It uses the <a class="el" href="classyarp_1_1dev_1_1IAudioGrabberSound.html" title="Read a YARP-format sound block from a device.">yarp::dev::IAudioGrabberSound</a> to control the attached device.</li>
</ul>
<p>Both the wrappers are open a port to receive/send data, and RPC port to receive user commands, a status port which displays some infos about the status of the wrapper. A list of the available RPC commands are displayed typing <code>help</code>.</p><ul>
<li>The <code>start</code> and <code>stop</code> commands are used to activate/disable the device. When stop command is sent to the recorder wrapper, it turns off the microphone of the attached device driver and no audio is grabbed from it. The wrapper thread will thus just wait for incoming data and nothing will be sent to the network. When start command is sent to the recorder wrapper, the recording is resumed and audio is sent to the network again. By default, the <a class="el" href="classAudioRecorderWrapper.html" title="AudioRecorderWrapper: A Wrapper which streams audio over the network, after grabbing it from a device">AudioRecorderWrapper</a> starts in disabled mode, and can be activated either via an rpc command or via &ndash;start parameter. When stop command is sent to the player wrapper, it turns off the playback of the attached device driver and no audio is played. When start command is sent to the player wrapper, the playback is resumed. Depending the configuration of the attached device, the buffer can be cleared or not, meaning that the interrupted audio can be resumed or start when a new audio is received. This functionality is managed through the DeviceBase class via the <code>AUDIO_BASE::buffer_autoclear</code> parameter (default false). A clear rpc command is also available to the user if he wants to clear the buffer on command. By default, the <a class="el" href="classAudioPlayerWrapper.html" title="AudioPlayerWrapper: A Wrapper which receives audio streams from a network port and sends it to device...">AudioPlayerWrapper</a> starts in disabled mode, and can be activated either via an rpc command or via &ndash;start parameter.</li>
<li>The <code>sw_audio_gain</code> is multiplier factor which can be use to adjust the playback/recording audio volume. A value equal to 0 corresponds to mute, a value between 0 and 1.0 corresponds to volume reduction, a value greater than 1.0 corresponds to amplification.</li>
<li>The <code>hw_audio_gain</code> has the same meaning of the sw audio gain, excepts for the fact that is passed to the low level device driver (which may implement it or not, depending on the hardware capabilities) instead of being handled by the wrapper. Both <code>sw_audio_gain</code> and <code>hw_audio_gain</code> can be set both via rpc command of as a startup parameter.</li>
</ul>
<p>An important <a class="el" href="classAudioRecorderWrapper.html" title="AudioRecorderWrapper: A Wrapper which streams audio over the network, after grabbing it from a device">AudioRecorderWrapper</a> set of parameters to understand is the composed by <code>min_samples_over_network</code>, <code>max_samples_over_network</code>, <code>max_samples_timeout</code> that are used to implement the following logic. The <a class="el" href="classAudioRecorderWrapper.html" title="AudioRecorderWrapper: A Wrapper which streams audio over the network, after grabbing it from a device">AudioRecorderWrapper</a> is a thread which periodically asks to the attached device new audio samples. This call is blocking until the device returns a number of samples greater than min_samples_over_network or if the max_samples_timeout timer (in seconds) expires. If this happens, the yarp sound will be sent anyway over the network, unless its size is zero. Instead, if the number of available samples exceeds <code>max_samples_over_network</code>, then these samples will be left in the internal buffer and will by obtained during the next thread iteration.</p>
<p>Regarding the <a class="el" href="classAudioPlayerWrapper.html" title="AudioPlayerWrapper: A Wrapper which receives audio streams from a network port and sends it to device...">AudioPlayerWrapper</a>, another important parameter to understand is <code>playback_network_buffer_size</code>. The values is expressed (in seconds). The wrapper stores received audio Sounds in an internal queue and starts the playback after waiting a corresponding amount of time. In this way the device driver has more to time to receive additional samples before a buffer underrun error (i.e. buffer empty) is triggered.</p>
<p>One final note regards the two status ports opened by <a class="el" href="classAudioPlayerWrapper.html" title="AudioPlayerWrapper: A Wrapper which receives audio streams from a network port and sends it to device...">AudioPlayerWrapper</a> and <a class="el" href="classAudioRecorderWrapper.html" title="AudioRecorderWrapper: A Wrapper which streams audio over the network, after grabbing it from a device">AudioRecorderWrapper</a> devices. These port broadcasts a specific yarp datatype <a class="el" href="classyarp_1_1dev_1_1AudioPlayerStatus.html" title="AudioPlayerStatus: A class used to describe the status of an audio player device.">yarp::dev::AudioPlayerStatus</a> / <a class="el" href="classyarp_1_1dev_1_1AudioRecorderStatus.html" title="AudioRecorderStatus: A class used to describe the status of an audio recorder device.">yarp::dev::AudioRecorderStatus</a> which contains info about the current status of the device, i.e. if is enabled or not, the size of internal buffer, the current number of samples contained in the buffer.</p>
<h1><a class="anchor" id="AudioExamples"></a>
Examples</h1>
<p>The following example reads an audio from a file, sends data through the network, and plays it on a speaker. The chosen configuration uses an internal buffer of 32000 samples (corresponding to 2 seconds of audio if audio samples with a freq of 16KHz are received). The playback has a latency of 0.1s. </p><div class="fragment"><div class="line">yarpdev --device audioRecorderWrapper --subdevice <a class="code" href="classaudioFromFileDevice.html">audioFromFileDevice</a> --start --file_name audio_in.wav</div>
<div class="line">yarpdev --device audioPlayerWrapper --subdevice portaudioPlayer --start --playback_network_buffer_size 0.1 --<a class="code" href="FfmpegWriter_8cpp.html#aeb8ae8386f8ee09979a92b7112576aef">AUDIO_BASE::samples</a> 32000</div>
<div class="line"><a class="code" href="namespaceyarp.html">yarp</a> connect /audioRecorderWrapper/audio:o /audioPlayerWrapper/audio:i</div>
<div class="ttc" id="aFfmpegWriter_8cpp_html_aeb8ae8386f8ee09979a92b7112576aef"><div class="ttname"><a href="FfmpegWriter_8cpp.html#aeb8ae8386f8ee09979a92b7112576aef">samples</a></div><div class="ttdeci">int16_t * samples</div><div class="ttdef"><b>Definition:</b> <a href="FfmpegWriter_8cpp_source.html#l00073">FfmpegWriter.cpp:73</a></div></div>
<div class="ttc" id="aclassaudioFromFileDevice_html"><div class="ttname"><a href="classaudioFromFileDevice.html">audioFromFileDevice</a></div><div class="ttdoc">audioFromFileDevice : This device driver, wrapped by default by AudioRecorderWrapper,...</div><div class="ttdef"><b>Definition:</b> <a href="audioFromFileDevice_8h_source.html#l00034">audioFromFileDevice.h:38</a></div></div>
<div class="ttc" id="anamespaceyarp_html"><div class="ttname"><a href="namespaceyarp.html">yarp</a></div><div class="ttdoc">The main, catch-all namespace for YARP.</div><div class="ttdef"><b>Definition:</b> <a href="dirs_8h_source.html#l00016">dirs.h:16</a></div></div>
</div><!-- fragment --><p>The following example grabs data from a microphone, sends data through the network, and saves it to a file. The chosen configuration forces the recorderWrapper to send data packets composed by 3200 samples, corresponding to 0.2s. </p><div class="fragment"><div class="line">yarpdev --device audioRecorderWrapper --subdevice portaudioRecorder --start --min_samples_over_network 3200 --max_samples_over_network 3200 --AUDIO_BASE::rate 16000 --<a class="code" href="FfmpegWriter_8cpp.html#aeb8ae8386f8ee09979a92b7112576aef">AUDIO_BASE::samples</a> 6400 --AUDIO_BASE::channels 1</div>
<div class="line">yarpdev --device audioPlayerWrapper --subdevice <a class="code" href="classaudioToFileDevice.html">audioToFileDevice</a> --start  --file_name audio_out.wav --save_mode overwrite_file</div>
<div class="line"><a class="code" href="namespaceyarp.html">yarp</a> connect /audioRecorderWrapper/audio:o /audioPlayerWrapper/audio:i</div>
<div class="ttc" id="aclassaudioToFileDevice_html"><div class="ttname"><a href="classaudioToFileDevice.html">audioToFileDevice</a></div><div class="ttdoc">audioToFileDevice : This device driver, wrapped by default by AudioPlayerWrapper, is used to save to ...</div><div class="ttdef"><b>Definition:</b> <a href="audioToFileDevice_8h_source.html#l00044">audioToFileDevice.h:47</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="AudioLimitations"></a>
Limitations</h1>
<p>The audio system currently do not support real-time audio transmission for audio conference purposes. Of course the systems allows to do it, as shown in following example: </p><div class="fragment"><div class="line">yarpdev --device audioRecorderWrapper --subdevice portaudioRecorder --start --min_samples_over_network 3200 --max_samples_over_network 3200 --AUDIO_BASE::rate 16000 --<a class="code" href="FfmpegWriter_8cpp.html#aeb8ae8386f8ee09979a92b7112576aef">AUDIO_BASE::samples</a> 6400 --AUDIO_BASE::channels 1</div>
<div class="line">yarpdev --device audioPlayerWrapper --subdevice portaudioPlayer --start --playback_network_buffer_size 0.1 --<a class="code" href="FfmpegWriter_8cpp.html#aeb8ae8386f8ee09979a92b7112576aef">AUDIO_BASE::samples</a> 32000</div>
<div class="line"><a class="code" href="namespaceyarp.html">yarp</a> connect /audioRecorderWrapper/audio:o /audioPlayerWrapper/audio:i</div>
</div><!-- fragment --><p> This example has several problems. First of some inevitable pop-clicks distortions will be happens, due to the fact the finite buffers have finite size. Since the network transmission has physical non-zero latency, the receiver accumulates more and more delay, having no physical way to recover from it and being unable to ask to the transmitter to perform a control action/send new data The only possible workaround is to set a very large buffer, which will introduce extra-latency but will make the buffer underrun occur less frequently. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.6.0</span></li>
    <li class="footer">Generated on Wed Jun 1 2022 14:48:30 for YARP by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
