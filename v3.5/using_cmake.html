<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Using CMake</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.5.1' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('using_cmake.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using CMake </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#using_cmake_basic">Hello World Example</a></li>
<li class="level1"><a href="#using_cmake_outofsource">Out-of-source Builds</a></li>
<li class="level1"><a href="#using_cmake_library">Building a library</a></li>
<li class="level1"><a href="#using_cmake_split">Building a library and program separately</a></li>
</ul>
</div>
<div class="textblock"><p>CMake lets you express the structure of your software in a portable way, that can then let you or others compile it with lots of different tools.</p>
<p>So, for example, you don't have to maintain Makefiles and Visual Studio projects, you can have a common "source" that can generate either.</p>
<p>It is possible to use YARP without CMake. But it isn't as much fun. So we give a basic tutorial on it here.</p>
<p>We gave instructions on installing CMake and getting started with a basic project here:</p>
<ul>
<li><a href="http://wiki.icub.org/wiki/CMake#Install_CMake">install_cmake</a></li>
</ul>
<p>Now we're going to go into CMake usage in a little more depth. But let's start simple, with a basic "hello world" example.</p>
<h1><a class="anchor" id="using_cmake_basic"></a>
Hello World Example</h1>
<p>Let's use CMake to compile the usual "hello world" program.</p>
<p>Create a directory "cmake_tutorial" to work in. Save the following as "main.cpp" within that directory:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  printf(<span class="stringliteral">&quot;hello world.\n&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ayarpros_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="yarpros_8cpp_source.html#l00263">yarpros.cpp:263</a></div></div>
</div><!-- fragment --><p>Then save the following as "CMakeLists.txt" within the same directory:</p>
<pre class="fragment">    cmake_minimum_required(VERSION 3.12)
    project(MyProject)
    add_executable(hello)
    target_sources(hello PRIVATE main.cpp)
</pre><p>The first line gives a CMake version number. CMake is evolving with time, so it is useful to warn a user if they have a version of CMake too old to work on your project. More importantly, by giving a version number CMake can support your project indefinitely into the future as its language changes.</p>
<p>The second line gives a name for our project. If we compile using Makefiles, this won't do anything, but if we compile with something like Visual Studio, the project name will be used for our workspace/solution.</p>
<p>The third line says we want to generate a program called "hello" (with whatever extension is common on the operating system used, ".exe" for Windows, nothing for Linux) and that to generate it we use the source file "main.cpp".</p>
<p>Now all we need to do is run CMake and we are ready to compile. In what follows, we describe running CMake on the command line, since it is easier to present. For instructions on using the CMake GUI on Windows, see:</p>
<ul>
<li><a href="http://wiki.icub.org/wiki/CMake#Install_CMake">install_cmake</a></li>
</ul>
<p>From the command-line, you can see all the options cmake takes by running it without any arguments.</p>
<p>we usually run cmake with a single argument that specifies the directory the source code is in. We could also specify what kind of tool we will want to build with (Unix Makefiles, CodeBlocks, Eclipse, KDevelop3, ...). By default, CMake will produce Unix Makefiles on systems where that make sense. If we want to compile in the same directory as our source code, that directory is ".", and here's what we see when we run cmake:</p>
<pre class="fragment">$ cmake .
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
-- Detecting C compiler info
-- Detecting C compiler info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler info
-- Detecting CXX compiler info - done
-- Configuring done
-- Generating done
-- Build files have been written to: ...
</pre><p>We can then compile; on Windows we would click on the workspace/solution file that CMake has just created, or in Linux we do "make":</p>
<pre class="fragment">$ make
Scanning dependencies of target hello
[100%] Building CXX object CMakeFiles/hello.dir/main.cpp.o
Linking CXX executable hello
[100%] Built target hello
</pre><p>Our program is now ready to run:</p>
<pre class="fragment">$ ./hello
hello world.
</pre><p>Success! But what was the point of all this? The point is that with our source code in C/C++, and our project description in CMake, our code can be compiled easily by users of a vast range of operating systems and tools. This makes collaborating with others a whole lot easier.</p>
<h1><a class="anchor" id="using_cmake_outofsource"></a>
Out-of-source Builds</h1>
<p>CMake generates a lot of helper files for compilation. In our "hello world" example, here are the files and directories we see after CMake has run:</p>
<pre class="fragment">$ ls
CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt
main.cpp        Makefile
</pre><p>Normally, we don't actually want all this junk mixed in with our source code. It is very common with CMake to do "out-of-source" builds, where compiling happens in a different directory to the source. So let's try doing this for our "hello world" example. First, let's clean up:</p>
<pre class="fragment">$ rm -rf CMakeCache.txt CMakeFiles cmake_install.cmake Makefile
$ ls
CMakeLists.txt  main.cpp
</pre><p>On Windows, just click on all files other than the two we wrote (CMakeLists.txt and main.cpp) and delete them. Now, let's build our program, but this time in a subdirectory called "build" (or whatever you like):</p>
<pre class="fragment">$ mkdir build
$ cd build
$ cmake ..
$ make
$ ./hello
</pre><p>(On Windows, make a subdirectory "build", then run CMake with the source directory set to where "main.cpp" is and the binary directory set to the "build" directory - then go through the compilation procedure again).</p>
<p>Now if we want to clean up, we can just remove the build directory.</p>
<p>The benefit of this method is that we can compile our code in lots of different ways side by side. This can be useful if you share a file system across several computers running different operating systems or compilers, or if your program takes a set of different compile options that you need to test.</p>
<h1><a class="anchor" id="using_cmake_library"></a>
Building a library</h1>
<p>We've seen an example of how to build a program. Now let's make a library as well. The library will be called "namer" and it will have a single function "getWorld" that returns the name of the nearest planet.</p>
<p>We choose to put this library in a subdirectory called "namer" - it doesn't really matter where we put it, this is just an example.</p>
<p>Here is a header file "namer/world.h": </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line">std::string getWorld();</div>
</div><!-- fragment --><p>And here is the corresponding implementation "namer/world.cpp": </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;namer/world.h&gt;</span></div>
<div class="line">std::string getWorld() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Earth&quot;</span>; }</div>
</div><!-- fragment --><p>And we update our "main.cpp" program to make use of the "getWorld" function: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;namer/world.h&gt;</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="yarpros_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  printf(<span class="stringliteral">&quot;Hello %s\n&quot;</span>, getWorld().c_str());</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the new include directive, for "world.h" (we could have said "namer/world.h" instead, it is up to us how we want to organize things).</p>
<p>Now we update the "CMakeLists.txt" to tell it about the library and to make sure the header file can be found by both the library and by "main.cpp": </p><pre class="fragment">    cmake_minimum_required(VERSION 3.12)
    project(MyProject)
    add_library(namer)
    target_sources(namer PRIVATE namer/world.cpp
                                 namer/world.h)
    target_include_directories(namer PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;
                                            $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}&gt;)

    add_executable(hello)
    target_sources(hello PRIVATE main.cpp)
    target_link_libraries(hello PRIVATE namer)
</pre><p>The <code>target_include_directories</code> command makes sure <code>namer/world.h</code> can be found when included in source code. We supply the path relative to <code>CMAKE_CURRENT_SOURCE_DIR</code>, which is a variable pointing to our source directory.</p>
<p>The <code>add_library</code> command tells CMake that we want to make a library called <code>namer</code> (<code>namer.lib</code> on Windows, <code>libnamer.a</code> or <code>libnamer.a</code> on Linux, ...) using the supplied source code. Note that header files should be included in this list (although it will work without them). There are extra commands you can use to organize code into different groups for presentation in IDEs like visual studio, but we'll skip over that.</p>
<p>The <code>target_link_libraries</code> says that program <code>hello</code> needs library <code>namer</code>.</p>
<p>And that's all! CMake will figure out all the details needed for your operating system and compiler to compile the library and link it to your program.</p>
<h1><a class="anchor" id="using_cmake_split"></a>
Building a library and program separately</h1>
<p>We've just seen how to build a library and a program all together in one project. In real life, libraries and programs often are written by different people working on different projects. Let's simulate that by breaking up our library and program into two separate projects.</p>
<p>Add the following CMake file for the library in "namer/CMakeLists.txt": </p><pre class="fragment">    cmake_minimum_required(VERSION 3.12)
    project(Namer)
    add_library(namer)
    target_sources(namer PRIVATE world.cpp world.h)
    target_include_directories(namer PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;
                                            $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}&gt;)
</pre><p> This is very similar to what we had before, except with our program pruned out.</p>
<p>Make a subdirectory "hello" and move "main.cpp" into it. Then add "hello/CMakeLists.txt":</p>
<pre class="fragment">    cmake_minimum_required(VERSION 3.12)
    project(hello)
    find_package(Namer REQUIRED)
    add_executable(hello)
    target_sources(hello PRIVATE main.cpp)
    target_include_directories(hello PRIVATE "${Namer_INCLUDE_DIRS}")
    target_link_libraries(hello PRIVATE ${Namer_LIBRARIES})
</pre><p>This is also similar to what we had before, except we now use the "find_package" command. This command is used to find external material that your project needs.</p>
<p>If you try configuring and compiling the library, it will work fine. But the executable will not work yet. You will get an error like this (depends on CMake version):</p>
<pre class="fragment">find_package could not find module FindNamer.cmake or a configuration
file for package Namer.  Adjust CMAKE_MODULE_PATH to find
FindNamer.cmake or set Namer_DIR to the directory containing a CMake
configuration file for Namer.  The file will have one of the following
names:
  NamerConfig.cmake
  namer-config.cmake
</pre><p>Basically, we haven't specified how to find the package Namer yet. CMake tried some ways it knows but none of them worked.</p>
<p>One way we can help CMake find the Namer package (which will be our namer library) is by writing a helper script called FindNamer.cmake. This is just another file written in the CMake language that pokes around in all the places our library might be hiding. Here is an example (put this in "hello/FindNamer.cmake"):</p>
<pre class="fragment">  find_path(Namer_INCLUDE_DIRS world.h /usr/include "$ENV{NAMER_ROOT}")

  find_library(Namer_LIBRARIES namer /usr/lib "$ENV{NAMER_ROOT}")

  set(Namer_FOUND TRUE)

  if (NOT Namer_INCLUDE_DIRS)
    set(Namer_FOUND FALSE)
  endif (NOT Namer_INCLUDE_DIRS)

  if (NOT Namer_LIBRARIES)
    set(Namer_FOUND FALSE)
  endif (NOT Namer_LIBRARIES)
</pre><p>The important parts here are the "find_path" and "find_library" commands, which look for the header file world.h and the namer library. I wrote them to check the Unix standard locations first, then a directory specified by an environment variable.</p>
<p>Now modify "hello/CMakeLists.txt" so that it can find this script: </p><pre class="fragment">    cmake_minimum_required(VERSION 3.12)
    set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}")
    find_package(Namer REQUIRED)
    include_directories("${Namer_INCLUDE_DIRS}")
    add_executable(hello)
    target_sources(hello PRIVATE main.cpp)
    target_link_libraries(hello PRIVATE ${Namer_LIBRARIES})
</pre><p>If we try again, configuration will still fail since the search path we gave for "find_path" and "find_library" doesn't actually include the needed files. We could copy them, or have added a hard-coded directory to find_path and find_library pointing to where the files are on our hard drive - but better, in the CMake GUI on windows or by running "ccmake ." on Linux, we can just fill in the directories there. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.5.1</span></li>
    <li class="footer">Generated on Sat Dec 25 2021 02:23:09 for YARP by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
