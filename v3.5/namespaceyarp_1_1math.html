<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: yarp::math Namespace Reference</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.5.1' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceyarp_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">yarp::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyarp_1_1math_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1FrameTransform.html">FrameTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1NormRand.html">NormRand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static class grouping function for normal random number generator.  <a href="classyarp_1_1math_1_1NormRand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1Quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1Rand.html">Rand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static class grouping function for uniform random number generator.  <a href="classyarp_1_1math_1_1Rand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1RandnScalar.html">RandnScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number generator, normal distribution.  <a href="classyarp_1_1math_1_1RandnScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1RandScalar.html">RandScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number generator, uniform in the range 0-1.  <a href="classyarp_1_1math_1_1RandScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyarp_1_1math_1_1Vec2D.html">Vec2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3036646e48e92590486219c0714b2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ae3036646e48e92590486219c0714b2d8">pile</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m1, const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:ae3036646e48e92590486219c0714b2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-Matrix concatenation by column (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ae3036646e48e92590486219c0714b2d8">More...</a><br /></td></tr>
<tr class="separator:ae3036646e48e92590486219c0714b2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2426c150acda8d6f86a2895e199474d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a2426c150acda8d6f86a2895e199474d2">pile</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v, const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a2426c150acda8d6f86a2895e199474d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-Matrix concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a2426c150acda8d6f86a2895e199474d2">More...</a><br /></td></tr>
<tr class="separator:a2426c150acda8d6f86a2895e199474d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6204c611e2168dbe46cb6ac00aa73d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a6204c611e2168dbe46cb6ac00aa73d86">pile</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a6204c611e2168dbe46cb6ac00aa73d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a6204c611e2168dbe46cb6ac00aa73d86">More...</a><br /></td></tr>
<tr class="separator:a6204c611e2168dbe46cb6ac00aa73d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eb4139eaf7a38429599514d0445e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a46eb4139eaf7a38429599514d0445e1d">pile</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v1, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v2)</td></tr>
<tr class="memdesc:a46eb4139eaf7a38429599514d0445e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a46eb4139eaf7a38429599514d0445e1d">More...</a><br /></td></tr>
<tr class="separator:a46eb4139eaf7a38429599514d0445e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c9ff20085fb1ceca14cf8b6fdb7f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a34c9ff20085fb1ceca14cf8b6fdb7f22">cat</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m1, const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a34c9ff20085fb1ceca14cf8b6fdb7f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-Matrix concatenation by row (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a34c9ff20085fb1ceca14cf8b6fdb7f22">More...</a><br /></td></tr>
<tr class="separator:a34c9ff20085fb1ceca14cf8b6fdb7f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e221c4f7008df2f3b45e3db91b1e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a87e221c4f7008df2f3b45e3db91b1e75">cat</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a87e221c4f7008df2f3b45e3db91b1e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a87e221c4f7008df2f3b45e3db91b1e75">More...</a><br /></td></tr>
<tr class="separator:a87e221c4f7008df2f3b45e3db91b1e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bc9df11f4466cd4e455b7527de976f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a78bc9df11f4466cd4e455b7527de976f">cat</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v, const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a78bc9df11f4466cd4e455b7527de976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-Matrix concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a78bc9df11f4466cd4e455b7527de976f">More...</a><br /></td></tr>
<tr class="separator:a78bc9df11f4466cd4e455b7527de976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2bb620de53f82468b0513a484e9c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a0c2bb620de53f82468b0513a484e9c1e">cat</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v1, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v2)</td></tr>
<tr class="memdesc:a0c2bb620de53f82468b0513a484e9c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a0c2bb620de53f82468b0513a484e9c1e">More...</a><br /></td></tr>
<tr class="separator:a0c2bb620de53f82468b0513a484e9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c4aa0a916ee54e1c0e7183379379a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a26c4aa0a916ee54e1c0e7183379379a3">cat</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v, double s)</td></tr>
<tr class="memdesc:a26c4aa0a916ee54e1c0e7183379379a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-scalar concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a26c4aa0a916ee54e1c0e7183379379a3">More...</a><br /></td></tr>
<tr class="separator:a26c4aa0a916ee54e1c0e7183379379a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e775ed9ae14540667482d9546bf5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a25e775ed9ae14540667482d9546bf5ef">cat</a> (double s, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a25e775ed9ae14540667482d9546bf5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a25e775ed9ae14540667482d9546bf5ef">More...</a><br /></td></tr>
<tr class="separator:a25e775ed9ae14540667482d9546bf5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c1ec6eeeef31c42ae2e0e91f8a073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a082c1ec6eeeef31c42ae2e0e91f8a073">cat</a> (double s1, double s2)</td></tr>
<tr class="memdesc:a082c1ec6eeeef31c42ae2e0e91f8a073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-scalar concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a082c1ec6eeeef31c42ae2e0e91f8a073">More...</a><br /></td></tr>
<tr class="separator:a082c1ec6eeeef31c42ae2e0e91f8a073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a08f008be636aab81415952f78583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a1c0a08f008be636aab81415952f78583">cat</a> (double s1, double s2, double s3)</td></tr>
<tr class="separator:a1c0a08f008be636aab81415952f78583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873f5f24fef92a179d261ce51b7dcff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a9873f5f24fef92a179d261ce51b7dcff">cat</a> (double s1, double s2, double s3, double s4)</td></tr>
<tr class="separator:a9873f5f24fef92a179d261ce51b7dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5128136d636c37cbb843c8adaa6826c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#af5128136d636c37cbb843c8adaa6826c">cat</a> (double s1, double s2, double s3, double s4, double s5)</td></tr>
<tr class="separator:af5128136d636c37cbb843c8adaa6826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2388d17868880e6974f5732731a58"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a9fc2388d17868880e6974f5732731a58">dot</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;a, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a9fc2388d17868880e6974f5732731a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a9fc2388d17868880e6974f5732731a58">More...</a><br /></td></tr>
<tr class="separator:a9fc2388d17868880e6974f5732731a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32213921f784dac911331b6accd8bcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ad32213921f784dac911331b6accd8bcc">outerProduct</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;a, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;b)</td></tr>
<tr class="memdesc:ad32213921f784dac911331b6accd8bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outer product between vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ad32213921f784dac911331b6accd8bcc">More...</a><br /></td></tr>
<tr class="separator:ad32213921f784dac911331b6accd8bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aa05f3c6b845b6125e8c4f29d73cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a38aa05f3c6b845b6125e8c4f29d73cd5">cross</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;a, const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a38aa05f3c6b845b6125e8c4f29d73cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product between two vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a38aa05f3c6b845b6125e8c4f29d73cd5">More...</a><br /></td></tr>
<tr class="separator:a38aa05f3c6b845b6125e8c4f29d73cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150366a3b596edc5aef06548c8cbb69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a5150366a3b596edc5aef06548c8cbb69">crossProductMatrix</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a5150366a3b596edc5aef06548c8cbb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product matrix, that is a 3-by-3 skew-symmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a5150366a3b596edc5aef06548c8cbb69">More...</a><br /></td></tr>
<tr class="separator:a5150366a3b596edc5aef06548c8cbb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b2f8ad96f92237701bf819e3b05d6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#aa9b2f8ad96f92237701bf819e3b05d6d">crossProductMatrix</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;res)</td></tr>
<tr class="memdesc:aa9b2f8ad96f92237701bf819e3b05d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product matrix, that is a 3-by-3 skew-symmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#aa9b2f8ad96f92237701bf819e3b05d6d">More...</a><br /></td></tr>
<tr class="separator:aa9b2f8ad96f92237701bf819e3b05d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378045a0a2b0cc5e7d9c6e54709ba127"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a378045a0a2b0cc5e7d9c6e54709ba127">norm</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a378045a0a2b0cc5e7d9c6e54709ba127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euclidean norm of the vector (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a378045a0a2b0cc5e7d9c6e54709ba127">More...</a><br /></td></tr>
<tr class="separator:a378045a0a2b0cc5e7d9c6e54709ba127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e750c2d428f88b87e223fbc0f79bb6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a52e750c2d428f88b87e223fbc0f79bb6">norm2</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a52e750c2d428f88b87e223fbc0f79bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euclidean squared norm of the vector (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a52e750c2d428f88b87e223fbc0f79bb6">More...</a><br /></td></tr>
<tr class="separator:a52e750c2d428f88b87e223fbc0f79bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c29543e126224d731d252d52e358ffb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a6c29543e126224d731d252d52e358ffb">findMax</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a6c29543e126224d731d252d52e358ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the elements of a real vector (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a6c29543e126224d731d252d52e358ffb">More...</a><br /></td></tr>
<tr class="separator:a6c29543e126224d731d252d52e358ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe6abbc565fe5f10f29e78f2a36be9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a76fe6abbc565fe5f10f29e78f2a36be9">findMin</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a76fe6abbc565fe5f10f29e78f2a36be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the elements of a real vector (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a76fe6abbc565fe5f10f29e78f2a36be9">More...</a><br /></td></tr>
<tr class="separator:a76fe6abbc565fe5f10f29e78f2a36be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c130b236e4f64c43cc905e29fa6dffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a6c130b236e4f64c43cc905e29fa6dffa">zeros</a> (int s)</td></tr>
<tr class="memdesc:a6c130b236e4f64c43cc905e29fa6dffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of zeros (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a6c130b236e4f64c43cc905e29fa6dffa">More...</a><br /></td></tr>
<tr class="separator:a6c130b236e4f64c43cc905e29fa6dffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc18305cc946efac9aa2ef2110742d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a3cc18305cc946efac9aa2ef2110742d0">ones</a> (int s)</td></tr>
<tr class="memdesc:a3cc18305cc946efac9aa2ef2110742d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of ones (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a3cc18305cc946efac9aa2ef2110742d0">More...</a><br /></td></tr>
<tr class="separator:a3cc18305cc946efac9aa2ef2110742d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052a3f5f259db0ef75ae0b70d4f54874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a052a3f5f259db0ef75ae0b70d4f54874">eye</a> (int r, int c)</td></tr>
<tr class="memdesc:a052a3f5f259db0ef75ae0b70d4f54874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an identity matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a052a3f5f259db0ef75ae0b70d4f54874">More...</a><br /></td></tr>
<tr class="separator:a052a3f5f259db0ef75ae0b70d4f54874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2071d9bcb423a600147b40a1673665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a7f2071d9bcb423a600147b40a1673665">eye</a> (int n)</td></tr>
<tr class="memdesc:a7f2071d9bcb423a600147b40a1673665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a square identity matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a7f2071d9bcb423a600147b40a1673665">More...</a><br /></td></tr>
<tr class="separator:a7f2071d9bcb423a600147b40a1673665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39877e4172674a6585a696da06623986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a39877e4172674a6585a696da06623986">zeros</a> (int r, int c)</td></tr>
<tr class="memdesc:a39877e4172674a6585a696da06623986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a matrix of zeros (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a39877e4172674a6585a696da06623986">More...</a><br /></td></tr>
<tr class="separator:a39877e4172674a6585a696da06623986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75e90a1e042e4d115513d70362120c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a5f75e90a1e042e4d115513d70362120c">det</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in)</td></tr>
<tr class="memdesc:a5f75e90a1e042e4d115513d70362120c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a5f75e90a1e042e4d115513d70362120c">More...</a><br /></td></tr>
<tr class="separator:a5f75e90a1e042e4d115513d70362120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a8b4e05b97b92f2e131a1fb5d9ca34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ac6a8b4e05b97b92f2e131a1fb5d9ca34">luinv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in)</td></tr>
<tr class="memdesc:ac6a8b4e05b97b92f2e131a1fb5d9ca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a square matrix using LU-decomposition (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ac6a8b4e05b97b92f2e131a1fb5d9ca34">More...</a><br /></td></tr>
<tr class="separator:ac6a8b4e05b97b92f2e131a1fb5d9ca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03c7c2ba2459d811789ede54306bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a4b03c7c2ba2459d811789ede54306bfc">eigenValues</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;real, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;img)</td></tr>
<tr class="memdesc:a4b03c7c2ba2459d811789ede54306bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues of the n-by-n real nonsymmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a4b03c7c2ba2459d811789ede54306bfc">More...</a><br /></td></tr>
<tr class="separator:a4b03c7c2ba2459d811789ede54306bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ce35dc0670a2930fc13c72335a7086"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a75ce35dc0670a2930fc13c72335a7086">sign</a> (const double &amp;v)</td></tr>
<tr class="memdesc:a75ce35dc0670a2930fc13c72335a7086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a symmetric and positive definite matrix using Cholesky decomposition (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a75ce35dc0670a2930fc13c72335a7086">More...</a><br /></td></tr>
<tr class="separator:a75ce35dc0670a2930fc13c72335a7086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a87f35294028b56cdc4775cbf7253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a8c1a87f35294028b56cdc4775cbf7253">sign</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a8c1a87f35294028b56cdc4775cbf7253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign vector of a real vector, that is a vector with 1 if the value is positive, -1 if negative, 0 if equal to zero (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a8c1a87f35294028b56cdc4775cbf7253">More...</a><br /></td></tr>
<tr class="separator:a8c1a87f35294028b56cdc4775cbf7253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc08ebf2ccf238ed811b90f563b18c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#aefc08ebf2ccf238ed811b90f563b18c8">dcm2axis</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;R)</td></tr>
<tr class="memdesc:aefc08ebf2ccf238ed811b90f563b18c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dcm (direction cosine matrix) rotation matrix R to axis/angle representation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#aefc08ebf2ccf238ed811b90f563b18c8">More...</a><br /></td></tr>
<tr class="separator:aefc08ebf2ccf238ed811b90f563b18c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0af22335399702f2b10a1d3eb0924df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ac0af22335399702f2b10a1d3eb0924df">axis2dcm</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;v)</td></tr>
<tr class="memdesc:ac0af22335399702f2b10a1d3eb0924df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dcm (direction cosine matrix) rotation matrix R from axis/angle representation (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ac0af22335399702f2b10a1d3eb0924df">More...</a><br /></td></tr>
<tr class="separator:ac0af22335399702f2b10a1d3eb0924df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73489a654a32b32187543f6955c64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#aac73489a654a32b32187543f6955c64a">dcm2euler</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;R)</td></tr>
<tr class="memdesc:aac73489a654a32b32187543f6955c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dcm (direction cosine matrix) rotation matrix to euler angles (ZYZ) (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#aac73489a654a32b32187543f6955c64a">More...</a><br /></td></tr>
<tr class="separator:aac73489a654a32b32187543f6955c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9">euler2dcm</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;euler)</td></tr>
<tr class="memdesc:ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts euler angles (ZYZ) vector in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9">More...</a><br /></td></tr>
<tr class="separator:ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14a738b45a6197d5db08a23564745d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ad14a738b45a6197d5db08a23564745d4">dcm2rpy</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;R)</td></tr>
<tr class="memdesc:ad14a738b45a6197d5db08a23564745d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dcm (direction cosine matrix) rotation matrix to roll-pitch-yaw angles (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#ad14a738b45a6197d5db08a23564745d4">More...</a><br /></td></tr>
<tr class="separator:ad14a738b45a6197d5db08a23564745d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b54571a34f67f993a2e0fe30a56856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a71b54571a34f67f993a2e0fe30a56856">rpy2dcm</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;rpy)</td></tr>
<tr class="memdesc:a71b54571a34f67f993a2e0fe30a56856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts roll-pitch-yaw angles in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a71b54571a34f67f993a2e0fe30a56856">More...</a><br /></td></tr>
<tr class="separator:a71b54571a34f67f993a2e0fe30a56856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43414765701ce5e5edb763cb63d7f381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a43414765701ce5e5edb763cb63d7f381">dcm2ypr</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;R)</td></tr>
<tr class="memdesc:a43414765701ce5e5edb763cb63d7f381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dcm (direction cosine matrix) rotation matrix to yaw-roll-pitch angles (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a43414765701ce5e5edb763cb63d7f381">More...</a><br /></td></tr>
<tr class="separator:a43414765701ce5e5edb763cb63d7f381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b4e42cbcc4fad11186c8b5122c135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a9f4b4e42cbcc4fad11186c8b5122c135">ypr2dcm</a> (const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;ypr)</td></tr>
<tr class="memdesc:a9f4b4e42cbcc4fad11186c8b5122c135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts yaw-pitch-roll angles in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a9f4b4e42cbcc4fad11186c8b5122c135">More...</a><br /></td></tr>
<tr class="separator:a9f4b4e42cbcc4fad11186c8b5122c135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468f0da22b03845285932f294a8f604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a6468f0da22b03845285932f294a8f604">SE3inv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;H)</td></tr>
<tr class="memdesc:a6468f0da22b03845285932f294a8f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of a 4 by 4 rototranslational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a6468f0da22b03845285932f294a8f604">More...</a><br /></td></tr>
<tr class="separator:a6468f0da22b03845285932f294a8f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79852aa7abfeab0116391876a1366964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a79852aa7abfeab0116391876a1366964">adjoint</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;H)</td></tr>
<tr class="memdesc:a79852aa7abfeab0116391876a1366964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the adjoint matrix of a given roto-translational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a79852aa7abfeab0116391876a1366964">More...</a><br /></td></tr>
<tr class="separator:a79852aa7abfeab0116391876a1366964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485f0808f33aa904f6e617c84a79c67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a6485f0808f33aa904f6e617c84a79c67">adjointInv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;H)</td></tr>
<tr class="memdesc:a6485f0808f33aa904f6e617c84a79c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the adjoint matrix of a given roto-translational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>).  <a href="namespaceyarp_1_1math.html#a6485f0808f33aa904f6e617c84a79c67">More...</a><br /></td></tr>
<tr class="separator:a6485f0808f33aa904f6e617c84a79c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e918215a821b55d3d388ef46c3aa7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a2e918215a821b55d3d388ef46c3aa7ef">SVD</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;U, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;S, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;V)</td></tr>
<tr class="memdesc:a2e918215a821b55d3d388ef46c3aa7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the M-by-N matrix 'in' into the singular value decomposition in = U S V^T (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a2e918215a821b55d3d388ef46c3aa7ef">More...</a><br /></td></tr>
<tr class="separator:a2e918215a821b55d3d388ef46c3aa7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32795629c2dfdb4a7a3aa219992f6bb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a32795629c2dfdb4a7a3aa219992f6bb0">SVDMod</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;U, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;S, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;V)</td></tr>
<tr class="memdesc:a32795629c2dfdb4a7a3aa219992f6bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SVD decomposition on a MxN matrix (for M &gt;= N) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a32795629c2dfdb4a7a3aa219992f6bb0">More...</a><br /></td></tr>
<tr class="separator:a32795629c2dfdb4a7a3aa219992f6bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8196499621c49f1ac6efadadf79badf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#af8196499621c49f1ac6efadadf79badf">SVDJacobi</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;U, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;S, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;V)</td></tr>
<tr class="memdesc:af8196499621c49f1ac6efadadf79badf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SVD decomposition on a matrix using the Jacobi method (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#af8196499621c49f1ac6efadadf79badf">More...</a><br /></td></tr>
<tr class="separator:af8196499621c49f1ac6efadadf79badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6efc9450d3d355c9f8198feca3bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a4ad6efc9450d3d355c9f8198feca3bbb">pinv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, double tol=0.0)</td></tr>
<tr class="memdesc:a4ad6efc9450d3d355c9f8198feca3bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a4ad6efc9450d3d355c9f8198feca3bbb">More...</a><br /></td></tr>
<tr class="separator:a4ad6efc9450d3d355c9f8198feca3bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f35e583bcdcfe7c7c8817e99b39089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ab4f35e583bcdcfe7c7c8817e99b39089">pinv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, double tol=0.0)</td></tr>
<tr class="memdesc:ab4f35e583bcdcfe7c7c8817e99b39089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#ab4f35e583bcdcfe7c7c8817e99b39089">More...</a><br /></td></tr>
<tr class="separator:ab4f35e583bcdcfe7c7c8817e99b39089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e2b854872aaf779e3ab99b67391185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a23e2b854872aaf779e3ab99b67391185">pinv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;sv, double tol=0.0)</td></tr>
<tr class="memdesc:a23e2b854872aaf779e3ab99b67391185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a23e2b854872aaf779e3ab99b67391185">More...</a><br /></td></tr>
<tr class="separator:a23e2b854872aaf779e3ab99b67391185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e8e493a8b723d85c13f2bd39b92a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ac07e8e493a8b723d85c13f2bd39b92a4">pinv</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;sv, double tol=0.0)</td></tr>
<tr class="memdesc:ac07e8e493a8b723d85c13f2bd39b92a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#ac07e8e493a8b723d85c13f2bd39b92a4">More...</a><br /></td></tr>
<tr class="separator:ac07e8e493a8b723d85c13f2bd39b92a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a4d8e98e271ecf359788411abb8b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a58a4d8e98e271ecf359788411abb8b97">pinvDamped</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;sv, double damp)</td></tr>
<tr class="memdesc:a58a4d8e98e271ecf359788411abb8b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a58a4d8e98e271ecf359788411abb8b97">More...</a><br /></td></tr>
<tr class="separator:a58a4d8e98e271ecf359788411abb8b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c21d210f32065536c067e5c8a6bd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a37c21d210f32065536c067e5c8a6bd7c">pinvDamped</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, double damp)</td></tr>
<tr class="memdesc:a37c21d210f32065536c067e5c8a6bd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a37c21d210f32065536c067e5c8a6bd7c">More...</a><br /></td></tr>
<tr class="separator:a37c21d210f32065536c067e5c8a6bd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c64a12601960508e9ab895c92472f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#aba5c64a12601960508e9ab895c92472f">pinvDamped</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, double damp)</td></tr>
<tr class="memdesc:aba5c64a12601960508e9ab895c92472f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#aba5c64a12601960508e9ab895c92472f">More...</a><br /></td></tr>
<tr class="separator:aba5c64a12601960508e9ab895c92472f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688a3d2269e02ab095c87ed999d7ed80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a688a3d2269e02ab095c87ed999d7ed80">pinvDamped</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;in, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;sv, double damp)</td></tr>
<tr class="memdesc:a688a3d2269e02ab095c87ed999d7ed80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a688a3d2269e02ab095c87ed999d7ed80">More...</a><br /></td></tr>
<tr class="separator:a688a3d2269e02ab095c87ed999d7ed80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134d9af598e4612e1db65c9f7f309952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a134d9af598e4612e1db65c9f7f309952">projectionMatrix</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;A, double tol=0.0)</td></tr>
<tr class="memdesc:a134d9af598e4612e1db65c9f7f309952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the projection matrix of A, that is defined as A times its pseudoinverse: A*pinv(A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a134d9af598e4612e1db65c9f7f309952">More...</a><br /></td></tr>
<tr class="separator:a134d9af598e4612e1db65c9f7f309952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad474d50660ee6cd37b09c903700092d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#ad474d50660ee6cd37b09c903700092d0">projectionMatrix</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;A, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, double tol=0.0)</td></tr>
<tr class="memdesc:ad474d50660ee6cd37b09c903700092d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the projection matrix of A, that is defined as A times its pseudoinverse: A*pinv(A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#ad474d50660ee6cd37b09c903700092d0">More...</a><br /></td></tr>
<tr class="separator:ad474d50660ee6cd37b09c903700092d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885489750d3b2c804d0fea105d046251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a885489750d3b2c804d0fea105d046251">nullspaceProjection</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;A, double tol=0.0)</td></tr>
<tr class="memdesc:a885489750d3b2c804d0fea105d046251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nullspace projection matrix of A, that is defined as the difference between the identity matrix and the pseudoinverse of A times A: (I - pinv(A)*A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a885489750d3b2c804d0fea105d046251">More...</a><br /></td></tr>
<tr class="separator:a885489750d3b2c804d0fea105d046251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aaaa230be02cbfe3ea2387ff2e1e6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyarp_1_1math.html#a41aaaa230be02cbfe3ea2387ff2e1e6c">nullspaceProjection</a> (const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;A, <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;out, double tol=0.0)</td></tr>
<tr class="memdesc:a41aaaa230be02cbfe3ea2387ff2e1e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nullspace projection matrix of A, that is defined as the difference between the identity matrix and the pseudoinverse of A times A: (I - pinv(A)*A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>).  <a href="namespaceyarp_1_1math.html#a41aaaa230be02cbfe3ea2387ff2e1e6c">More...</a><br /></td></tr>
<tr class="separator:a41aaaa230be02cbfe3ea2387ff2e1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79852aa7abfeab0116391876a1366964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79852aa7abfeab0116391876a1366964">&#9670;&nbsp;</a></span>adjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::adjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the adjoint matrix of a given roto-translational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>The adjoint is a (6x6) matrix: [R , S(r)*R; 0, R] where R is the rotational part of H, and r the translational part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>is the 4 by 4 rototranslational matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjoint matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00933">933</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a6485f0808f33aa904f6e617c84a79c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6485f0808f33aa904f6e617c84a79c67">&#9670;&nbsp;</a></span>adjointInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::adjointInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of the adjoint matrix of a given roto-translational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>The inverse of an adjoint is a (6x6) matrix: [R^T , -S(R^T*r)*R^T; 0 , R^T] where R is the rotational part of H, and r the translational part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>is the 4 by 4 rototranslational matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of the adjoint matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00959">959</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ac0af22335399702f2b10a1d3eb0924df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0af22335399702f2b10a1d3eb0924df">&#9670;&nbsp;</a></span>axis2dcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::axis2dcm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a dcm (direction cosine matrix) rotation matrix R from axis/angle representation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the axis/angle vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4 by 4 homogeneous matrix with the rotation components in the top left 3 by 3 submatrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00715">715</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a87e221c4f7008df2f3b45e3db91b1e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e221c4f7008df2f3b45e3db91b1e75">&#9670;&nbsp;</a></span>cat() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Add a column at the end of a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">v</td><td>a vector n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix nX(m+1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00377">377</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a34c9ff20085fb1ceca14cf8b6fdb7f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c9ff20085fb1ceca14cf8b6fdb7f22">&#9670;&nbsp;</a></span>cat() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-Matrix concatenation by row (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">m2</td><td>a matrix nXr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix nX(m+r) </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00363">363</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a78bc9df11f4466cd4e455b7527de976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bc9df11f4466cd4e455b7527de976f">&#9670;&nbsp;</a></span>cat() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector-Matrix concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Add a column at the beginning of a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">v</td><td>a vector n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix nX(m+1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00390">390</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a26c4aa0a916ee54e1c0e7183379379a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c4aa0a916ee54e1c0e7183379379a3">&#9670;&nbsp;</a></span>cat() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector-scalar concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Create a vector by putting the scalar at the end of the vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an n-vector </td></tr>
    <tr><td class="paramname">s</td><td>a scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a (n+1)-vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00415">415</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a0c2bb620de53f82468b0513a484e9c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2bb620de53f82468b0513a484e9c1e">&#9670;&nbsp;</a></span>cat() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Create a vector by putting two vectors side by side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>an n-vector </td></tr>
    <tr><td class="paramname">v2</td><td>an m-vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a (n+m)-vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00403">403</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a25e775ed9ae14540667482d9546bf5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e775ed9ae14540667482d9546bf5ef">&#9670;&nbsp;</a></span>cat() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar-vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Create a vector by putting the scalar at the beginning of the vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a scalar </td></tr>
    <tr><td class="paramname">v</td><td>an n-vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a (n+1)-vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00426">426</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a082c1ec6eeeef31c42ae2e0e91f8a073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082c1ec6eeeef31c42ae2e0e91f8a073">&#9670;&nbsp;</a></span>cat() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar-scalar concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Create a vector containing the two specified scalar values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>a scalar </td></tr>
    <tr><td class="paramname">s2</td><td>a scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 2-vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00437">437</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a1c0a08f008be636aab81415952f78583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0a08f008be636aab81415952f78583">&#9670;&nbsp;</a></span>cat() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00445">445</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a9873f5f24fef92a179d261ce51b7dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9873f5f24fef92a179d261ce51b7dcff">&#9670;&nbsp;</a></span>cat() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00454">454</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="af5128136d636c37cbb843c8adaa6826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5128136d636c37cbb843c8adaa6826c">&#9670;&nbsp;</a></span>cat() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00464">464</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a38aa05f3c6b845b6125e8c4f29d73cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38aa05f3c6b845b6125e8c4f29d73cd5">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product between two vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first input vector </td></tr>
    <tr><td class="paramname">b</td><td>second input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>axb </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00496">496</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a5150366a3b596edc5aef06548c8cbb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150366a3b596edc5aef06548c8cbb69">&#9670;&nbsp;</a></span>crossProductMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::crossProductMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product matrix, that is a 3-by-3 skew-symmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cross product matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00507">507</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="aa9b2f8ad96f92237701bf819e3b05d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b2f8ad96f92237701bf819e3b05d6d">&#9670;&nbsp;</a></span>crossProductMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool yarp::math::crossProductMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product matrix, that is a 3-by-3 skew-symmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector </td></tr>
    <tr><td class="paramname">res</td><td>the cross product matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if operation succeeded, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00520">520</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="aefc08ebf2ccf238ed811b90f563b18c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc08ebf2ccf238ed811b90f563b18c8">&#9670;&nbsp;</a></span>dcm2axis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::dcm2axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dcm (direction cosine matrix) rotation matrix R to axis/angle representation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is the input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4 by 1 vector for the axis/angle representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00673">673</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="aac73489a654a32b32187543f6955c64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac73489a654a32b32187543f6955c64a">&#9670;&nbsp;</a></span>dcm2euler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::dcm2euler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dcm (direction cosine matrix) rotation matrix to euler angles (ZYZ) (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Three angles are returned in a vector with the following format: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\alpha, \beta, \gamma ]\]" src="form_8.png"/>
</p>
<p> such that the returned matrix satisfies the following: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_z(\alpha) R_y(\beta) R_z(\gamma) \]" src="form_9.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is the input ZYZ rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3 by 1 vector for the Euler angles representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00753">753</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ad14a738b45a6197d5db08a23564745d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14a738b45a6197d5db08a23564745d4">&#9670;&nbsp;</a></span>dcm2rpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::dcm2rpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dcm (direction cosine matrix) rotation matrix to roll-pitch-yaw angles (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Three angles are returned in a vector with the following format: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\psi, \theta, \phi ]\]" src="form_10.png"/>
</p>
<p> such that the returned matrix satisfies the following: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_z(\phi) R_y(\theta) R_x(\psi) \]" src="form_11.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is the input ZYX rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3 by 1 vector for the roll pitch-yaw-angles representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00808">808</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a43414765701ce5e5edb763cb63d7f381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43414765701ce5e5edb763cb63d7f381">&#9670;&nbsp;</a></span>dcm2ypr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::dcm2ypr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dcm (direction cosine matrix) rotation matrix to yaw-roll-pitch angles (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Three angles are returned in a vector with the following format: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\phi, \theta, \psi ]\]" src="form_12.png"/>
</p>
<p> such that the returned matrix satisfies the following: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_x(\psi) R_y(\theta) R_z(\phi) \]" src="form_13.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is the input XYZ rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3 by 1 vector for the yaw-pitch-roll angles representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00863">863</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a5f75e90a1e042e4d115513d70362120c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75e90a1e042e4d115513d70362120c">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00607">607</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a9fc2388d17868880e6974f5732731a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc2388d17868880e6974f5732731a58">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar product between vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>a^T*b, where a and b are column vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00475">475</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a4b03c7c2ba2459d811789ede54306bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b03c7c2ba2459d811789ede54306bfc">&#9670;&nbsp;</a></span>eigenValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool yarp::math::eigenValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>real</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes eigenvalues of the n-by-n real nonsymmetric matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>nonsymmetric n-by-n matrix </td></tr>
    <tr><td class="paramname">real</td><td>the real part of eigen values </td></tr>
    <tr><td class="paramname">img</td><td>the imaginary part of eigen values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the real and imaginary part of the eigen values in separate matrices </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00624">624</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b4dbaf3bbdf8da4b55bdc0c3b1f4a9">&#9670;&nbsp;</a></span>euler2dcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::euler2dcm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>euler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts euler angles (ZYZ) vector in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>The three euler angles are specified in a vector with the following structure: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\alpha, \beta, \gamma ]\]" src="form_8.png"/>
</p>
<p> and the returned matrix is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_z(\alpha) R_y(\beta) R_z(\gamma) \]" src="form_9.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">euler</td><td>is the input vector (alpha=z-rotation, beta=y-rotation, gamma=z-rotation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4 by 4 homogeneous matrix representing the ZYZ rotation with the rotation components in the top left 3 by 3 submatrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00792">792</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a7f2071d9bcb423a600147b40a1673665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2071d9bcb423a600147b40a1673665">&#9670;&nbsp;</a></span>eye() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::eye </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a square identity matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of rows and columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00594">594</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a052a3f5f259db0ef75ae0b70d4f54874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052a3f5f259db0ef75ae0b70d4f54874">&#9670;&nbsp;</a></span>eye() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::eye </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an identity matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>number of rows </td></tr>
    <tr><td class="paramname">c</td><td>number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00586">586</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a6c29543e126224d731d252d52e358ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c29543e126224d731d252d52e358ffb">&#9670;&nbsp;</a></span>findMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::findMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum of the elements of a real vector (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(v). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00548">548</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a76fe6abbc565fe5f10f29e78f2a36be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fe6abbc565fe5f10f29e78f2a36be9">&#9670;&nbsp;</a></span>findMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::findMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum of the elements of a real vector (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(v). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00562">562</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ac6a8b4e05b97b92f2e131a1fb5d9ca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a8b4e05b97b92f2e131a1fb5d9ca34">&#9670;&nbsp;</a></span>luinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::luinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a square matrix using LU-decomposition (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of the matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00612">612</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a378045a0a2b0cc5e7d9c6e54709ba127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378045a0a2b0cc5e7d9c6e54709ba127">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Euclidean norm of the vector (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>||v||. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00538">538</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a52e750c2d428f88b87e223fbc0f79bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e750c2d428f88b87e223fbc0f79bb6">&#9670;&nbsp;</a></span>norm2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Euclidean squared norm of the vector (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>||v||^2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00543">543</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a885489750d3b2c804d0fea105d046251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885489750d3b2c804d0fea105d046251">&#9670;&nbsp;</a></span>nullspaceProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::nullspaceProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nullspace projection matrix of A, that is defined as the difference between the identity matrix and the pseudoinverse of A times A: (I - pinv(A)*A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>Multiplying this null projection matrix times a vector projects the vector in the nullspace of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection matrix associated with the nullspace of A </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00187">187</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a41aaaa230be02cbfe3ea2387ff2e1e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aaaa230be02cbfe3ea2387ff2e1e6c">&#9670;&nbsp;</a></span>nullspaceProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::nullspaceProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nullspace projection matrix of A, that is defined as the difference between the identity matrix and the pseudoinverse of A times A: (I - pinv(A)*A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>Multiplying this projection matrix times a vector projects the vector in the range of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>the projection matrix associated with the nullspace of A </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00194">194</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a3cc18305cc946efac9aa2ef2110742d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc18305cc946efac9aa2ef2110742d0">&#9670;&nbsp;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::ones </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of ones (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the size of the new vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the new vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00581">581</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ad32213921f784dac911331b6accd8bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32213921f784dac911331b6accd8bcc">&#9670;&nbsp;</a></span>outerProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::outerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outer product between vectors (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>a*b^T, where a and b are column vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00483">483</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a6204c611e2168dbe46cb6ac00aa73d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6204c611e2168dbe46cb6ac00aa73d86">&#9670;&nbsp;</a></span>pile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Add a row at the end of a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">v</td><td>a vector m </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix (n+1)Xm </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00325">325</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="ae3036646e48e92590486219c0714b2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3036646e48e92590486219c0714b2d8">&#9670;&nbsp;</a></span>pile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-Matrix concatenation by column (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">m2</td><td>a matrix rXm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix (n+r)Xm </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00311">311</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a2426c150acda8d6f86a2895e199474d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2426c150acda8d6f86a2895e199474d2">&#9670;&nbsp;</a></span>pile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector-Matrix concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Add a row at the beginning of a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a matrix nXm </td></tr>
    <tr><td class="paramname">v</td><td>a vector m </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix (n+1)Xm </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00338">338</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a46eb4139eaf7a38429599514d0445e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eb4139eaf7a38429599514d0445e1d">&#9670;&nbsp;</a></span>pile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector-Vector concatenation (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>Create a two row matrix by stacking two vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>an n-vector </td></tr>
    <tr><td class="paramname">v2</td><td>an n-vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix 2Xn </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00351">351</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a4ad6efc9450d3d355c9f8198feca3bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad6efc9450d3d355c9f8198feca3bbb">&#9670;&nbsp;</a></span>pinv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo-inverse of the matrix 'in' </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00046">46</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="ab4f35e583bcdcfe7c7c8817e99b39089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f35e583bcdcfe7c7c8817e99b39089">&#9670;&nbsp;</a></span>pinv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::pinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>pseudo-inverse of the matrix 'in' </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00063">63</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="ac07e8e493a8b723d85c13f2bd39b92a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07e8e493a8b723d85c13f2bd39b92a4">&#9670;&nbsp;</a></span>pinv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::pinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>pseudo-inverse of the matrix 'in' </td></tr>
    <tr><td class="paramname">sv</td><td>vector containing the singular values of the input matrix </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00100">100</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a23e2b854872aaf779e3ab99b67391185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2b854872aaf779e3ab99b67391185">&#9670;&nbsp;</a></span>pinv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the moore-penrose pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">sv</td><td>vector containing the singular values of the input matrix </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo-inverse of the matrix 'in' </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00080">80</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a37c21d210f32065536c067e5c8a6bd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c21d210f32065536c067e5c8a6bd7c">&#9670;&nbsp;</a></span>pinvDamped() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pinvDamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">damp</td><td>damping factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00127">127</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="aba5c64a12601960508e9ab895c92472f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5c64a12601960508e9ab895c92472f">&#9670;&nbsp;</a></span>pinvDamped() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::pinvDamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>damped pseudo-inverse of the matrix 'in' </td></tr>
    <tr><td class="paramname">damp</td><td>damping factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00136">136</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a688a3d2269e02ab095c87ed999d7ed80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a3d2269e02ab095c87ed999d7ed80">&#9670;&nbsp;</a></span>pinvDamped() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::pinvDamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>damped pseudo-inverse of the matrix 'in' </td></tr>
    <tr><td class="paramname">sv</td><td>vector containing the singular values of the input matrix </td></tr>
    <tr><td class="paramname">damp</td><td>damping factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00143">143</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a58a4d8e98e271ecf359788411abb8b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a4d8e98e271ecf359788411abb8b97">&#9670;&nbsp;</a></span>pinvDamped() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::pinvDamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the damped pseudo-inverse of a matrix (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input matrix </td></tr>
    <tr><td class="paramname">sv</td><td>vector containing the singular values of the input matrix </td></tr>
    <tr><td class="paramname">damp</td><td>damping factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00120">120</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a134d9af598e4612e1db65c9f7f309952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134d9af598e4612e1db65c9f7f309952">&#9670;&nbsp;</a></span>projectionMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::projectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the projection matrix of A, that is defined as A times its pseudoinverse: A*pinv(A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>Multiplying this projection matrix times a vector projects the vector in the range of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection matrix associated with the range of A </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00162">162</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="ad474d50660ee6cd37b09c903700092d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad474d50660ee6cd37b09c903700092d0">&#9670;&nbsp;</a></span>projectionMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::projectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the projection matrix of A, that is defined as A times its pseudoinverse: A*pinv(A) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>Multiplying this projection matrix times a vector projects the vector in the range of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">out</td><td>the projection matrix associated with the range of A </td></tr>
    <tr><td class="paramname">tol</td><td>singular values less than tol are set to zero </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00169">169</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a71b54571a34f67f993a2e0fe30a56856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b54571a34f67f993a2e0fe30a56856">&#9670;&nbsp;</a></span>rpy2dcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::rpy2dcm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rpy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts roll-pitch-yaw angles in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>The three angles are specified in a vector with the following structure: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\psi, \theta, \phi ]\]" src="form_10.png"/>
</p>
<p> and the returned matrix is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_z(\phi) R_y(\theta) R_x(\psi) \]" src="form_11.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpy</td><td>is the input vector (\psi=roll x-rotation,\theta=pitch y-rotation, \phi=yaw z-rotation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4 by 4 homogeneous matrix representing the ZYX rotation with the rotation components in the top left 3 by 3 submatrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00847">847</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a6468f0da22b03845285932f294a8f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6468f0da22b03845285932f294a8f604">&#9670;&nbsp;</a></span>SE3inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::SE3inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of a 4 by 4 rototranslational matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>is the 4 by 4 rototranslational matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverse of 4 by 4 rototranslational matrix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>about 5 times faster than <a class="el" href="namespaceyarp_1_1math.html#a4ad6efc9450d3d355c9f8198feca3bbb" title="Perform the moore-penrose pseudo-inverse of a matrix (defined in SVD.h).">pinv()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00912">912</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a75ce35dc0670a2930fc13c72335a7086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ce35dc0670a2930fc13c72335a7086">&#9670;&nbsp;</a></span>sign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double yarp::math::sign </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a symmetric and positive definite matrix using Cholesky decomposition (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>symmetric and positive definite matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of the matrix Returns the sign of a real number: 1 if positive, -1 if negative, 0 if equal to zero (defined in <a class="el" href="Math_8h.html">Math.h</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sign(v). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00657">657</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a8c1a87f35294028b56cdc4775cbf7253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1a87f35294028b56cdc4775cbf7253">&#9670;&nbsp;</a></span>sign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sign vector of a real vector, that is a vector with 1 if the value is positive, -1 if negative, 0 if equal to zero (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sign(v). </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00663">663</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a2e918215a821b55d3d388ef46c3aa7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e918215a821b55d3d388ef46c3aa7ef">&#9670;&nbsp;</a></span>SVD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::SVD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize the M-by-N matrix 'in' into the singular value decomposition in = U S V^T (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>The diagonal elements of the singular value matrix S are stored in the vector S. The singular values are non-negative and form a non-increasing sequence from S_1 to S_N. The matrix V contains the elements of V in untransposed form. To form the product U S V^T it is necessary to take the transpose of V. Defining K as min(M, N) the the input matrices are: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input M-by-N matrix to decompose </td></tr>
    <tr><td class="paramname">U</td><td>output M-by-K orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>output K-dimensional vector containing the diagonal entries of the diagonal matrix S </td></tr>
    <tr><td class="paramname">V</td><td>output N-by-K orthogonal matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If U, S, V do not have the expected sizes they are resized automatically.</dd>
<dd>
The routine computes the <em>thin</em> version of the SVD. Mathematically, the <em>full</em> SVD is defined with U and V as square orthogonal matrices and S as an M-by-N diagonal matrix.</dd>
<dd>
This function uses the Jacobi SVD algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00022">22</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="af8196499621c49f1ac6efadadf79badf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8196499621c49f1ac6efadadf79badf">&#9670;&nbsp;</a></span>SVDJacobi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::SVDJacobi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform SVD decomposition on a matrix using the Jacobi method (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<p>The Jacobi method can compute singular values to higher relative accuracy than Golub-Reinsch algorithms.</p>
<dl class="section note"><dt>Note</dt><dd>If U, S, V do not have the expected sizes they are resized automatically.</dd>
<dd>
This function uses the Jacobi SVD algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00032">32</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a32795629c2dfdb4a7a3aa219992f6bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32795629c2dfdb4a7a3aa219992f6bb0">&#9670;&nbsp;</a></span>SVDMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yarp::math::SVDMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">yarp::sig::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform SVD decomposition on a MxN matrix (for M &gt;= N) (defined in <a class="el" href="SVD_8h.html">SVD.h</a>). </p>
<dl class="section note"><dt>Note</dt><dd>If U, S, V do not have the expected sizes they are resized automatically.</dd>
<dd>
This function uses the Jacobi SVD algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SVD_8cpp_source.html#l00027">27</a> of file <a class="el" href="SVD_8cpp_source.html">SVD.cpp</a>.</p>

</div>
</div>
<a id="a9f4b4e42cbcc4fad11186c8b5122c135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b4e42cbcc4fad11186c8b5122c135">&#9670;&nbsp;</a></span>ypr2dcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::ypr2dcm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">yarp::sig::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ypr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts yaw-pitch-roll angles in the corresponding dcm (direction cosine matrix) rotation matrix (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<p>The three angles are specified in a vector with the following structure: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v} = [\phi, \theta, \psi ]\]" src="form_12.png"/>
</p>
<p> and the returned matrix is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = R_x(\psi) R_y(\theta) R_z(\phi) \]" src="form_13.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ypr</td><td>is the input vector (\phi=yaw z-rotation, \theta=pitch y-rotation, \psi=roll x-rotation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4 by 4 homogeneous matrix representing the XYZ rotation with the rotation components in the top left 3 by 3 submatrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00896">896</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a39877e4172674a6585a696da06623986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39877e4172674a6585a696da06623986">&#9670;&nbsp;</a></span>zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyarp_1_1sig_1_1Matrix.html">Matrix</a> yarp::math::zeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a matrix of zeros (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>number of rows </td></tr>
    <tr><td class="paramname">c</td><td>number of columns </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00599">599</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
<a id="a6c130b236e4f64c43cc905e29fa6dffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c130b236e4f64c43cc905e29fa6dffa">&#9670;&nbsp;</a></span>zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyarp_1_1sig.html#a2de82e49cbfebd4aa484e126319dc45f">Vector</a> yarp::math::zeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of zeros (defined in <a class="el" href="Math_8h.html">Math.h</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the size of the new vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the new vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8cpp_source.html#l00576">576</a> of file <a class="el" href="math_8cpp_source.html">math.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.5.1</span></li>
    <li class="navelem"><a class="el" href="namespaceyarp.html">yarp</a></li><li class="navelem"><a class="el" href="namespaceyarp_1_1math.html">math</a></li>
    <li class="footer">Generated on Sat Dec 25 2021 02:23:13 for YARP by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
