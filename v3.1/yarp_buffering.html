<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YARP: Buffering Policies in YARP</title>
<link rel="shortcut icon" href="yarp-favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = { VERSION: '3.1.2' };
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="yarp-doxygen-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../version_switch.js"></script>
<link rel="stylesheet" type="text/css" href="cookieconsent.min.css" />
<script src="cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#eb6c44",
      "text": "#ffffff"
    },
    "button": {
      "background": "#237afc",
    }
  },
  "theme": "classic",
  "content": {
    "message": "INFORMATION NOTICE ON COOKIES : This website uses only browsing/session cookies. Users can choose whether or not to accept the use of cookies and access the website. By clicking on \"Further information\", the full information notice on the types of cookies will be displayed and you will be able  to choose whether or not to accept them whilst browsing on the website.",
    "dismiss": "ACCEPT and close",
    "link": "Further information",
    "href": "http://www.icub.org/other/personal_data_notice.html"
  }
})});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="yarp-robot-64.png"/></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">YARP</div>
   <div id="projectbrief">Yet Another Robot Platform</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('yarp_buffering.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Buffering Policies in YARP </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page assumes you are familiar with the use of YARP <a class="el" href="classyarp_1_1os_1_1Port.html" title="A mini-server for network communication.">yarp::os::Port</a> and <a class="el" href="classyarp_1_1os_1_1BufferedPort.html" title="A mini-server for performing network communication in the background.">yarp::os::BufferedPort</a> objects.</p>
<p>If this is not the case, you may want to go back and have a look at the following pages before you continue:</p>
<ul>
<li>note_ports </li>
<li><a class="el" href="port_expert.html">Port Power, Going Further with Ports</a></li>
</ul>
<p>Read and write operations with YARP Port are blocking, this means that readers and senders wait for each other ensuring that all messages are transmitted on the network. Notice that this means that YARP itself will not drop messages, if you use a non reliable protocol (like UDP) messages may still be dropped on by the network layer (this may happen frequently on a busy network).</p>
<p>In robotic applications it is often wise to decouple timing before senders and receivers. This is useful, because you want to avoid interference between readers that go at different speeds. At this aim YARP provides a specific type of port called BufferedPort.</p>
<p>In a BufferedPort messages are sent and received in the background without having to stop your processing. This requires a little care to understand the life-cycle of objects written to and read from the network (see <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a> and <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af24f1371b310763572aa7f22459fd71d" title="Write the current object being returned by BufferedPort::prepare.">yarp::os::BufferedPort::write()</a>).</p>
<p>By default a BufferedPort attempts to reduce latency between senders and receivers. To do so messages may be dropped by the writer if <a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a> is called too quickly. The reader may also drop messages that arrive between subsequent calls to <a class="el" href="namespaceyarp_1_1sig_1_1file.html#a07569dcd80588910b9f97d167185e870">BufferedPort::read()</a>, this ensures that in slow readers new messages travel with high priority. This policy is sometimes called Oldest Packet Drop (ODP).</p>
<p>If your application cannot afford dropping messages you can change the buffering policy. Use <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#a5b162e30ad21b6c506520c4fde2c7377" title="Write the current object being returned by BufferedPort::prepare, waiting until any previous sends ar...">yarp::os::BufferedPort::writeStrict()</a> when writing to a port, this waits for pending transmissions to be finished before writing new data. Call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aecb5533cb8005f6fe4278d292ec21033" title="Call this to strictly keep all messages, or allow old ones to be quietly dropped.">yarp::os::BufferedPort::setStrict()</a> to change the buffering policy to FIFO at the receiver side. In this way all messages will be stored inside the BufferedPort and delivered to the reader. Pay attention that in this case a slow reader may experience increasing latency and that the BufferedPort may allocate memory in the background.</p>
<p>Methods that can be useful to monitor the status of read and write operations are: <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#a94b8c3e80cdf71ed2013a4a839a46c1b" title="Get the number of objects ready to be read.">yarp::os::BufferedPort::getPendingReads()</a> and <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aba9a714a20524d9a6da2127d1102c3da" title="Report whether the port is currently writing data.">yarp::os::BufferedPort::isWriting()</a>.</p>
<p>It is also important to understand that a BufferedPort is managing the life-cycle of the messages transmitted on the network. This means that the BufferedPort will allocate and re-cycle objects in its internal buffers.</p>
<h1><a class="anchor" id="s_buffering_writing"></a>
Life-cycle: writing to a port</h1>
<p>When you call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66" title="Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.">yarp::os::BufferedPort::prepare()</a> you get a slot from the internal buffer. This slot is reserved for you, until the next call to <a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a>. This means that you are free to write inside the object returned by BufferedPort::prepare(), until the next call to <a class="el" href="namespaceyarp_1_1sig_1_1file.html#ab329defdeb7a6f62ebc1ce82978e69c5">BufferedPort::write()</a>. At this point the YARP infrastructure will begin transmitting the message and you are no longer allowed to modify it (well, actually nobody forbids doing so, but in this case you may have unexpected effects, i.e. probably the message will be corrupted).</p>
<p>Objects are recycled within the BufferedPort to save CPU cycles, so the next time you call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#af79f22ea0a51e1e6262a13ed83227b66" title="Access the object which will be transmitted by the next call to yarp::os::BufferedPort::write.">yarp::os::BufferedPort::prepare()</a> you will not get an empty object. Make sure you clean the object before you write to it (for example do not append data to a Bottle), otherwise you will get unexpected behavior (likely the object will contain past data). This code example illustrates this concept:</p>
<div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; port;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Bottle &amp;b=port.prepare();</div>
<div class="line"><span class="comment">//write to b</span></div>
<div class="line">port.<a class="code" href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">write</a>();</div>
<div class="line"><span class="comment">// don&#39;t touch b!</span></div>
</div><!-- fragment --><h1><a class="anchor" id="s_buffering_reading"></a>
Life-cycle: reading from a port</h1>
<p>To read from a BufferedPort you call <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a>, this returns a pointer to the message which arrived most recently (or the oldest message in the queue, if you changed the buffering policy to FIFO using <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#aecb5533cb8005f6fe4278d292ec21033" title="Call this to strictly keep all messages, or allow old ones to be quietly dropped.">yarp::os::BufferedPort::setStrict()</a>). This object is reserved and not touched by YARP, until the next call to <a class="el" href="classyarp_1_1os_1_1BufferedPort.html#ad88d8d901b29e3776281b943a4f47596" title="Read an available object from the port.">yarp::os::BufferedPort::read()</a>. This code example clarify this issue:</p>
<div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; port;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Bottle *b1=port.read();</div>
<div class="line"><span class="comment">// read b1, YARP will not touch it until the next call to read().</span></div>
<div class="line"> </div>
<div class="line">Bottle *b2=port.read();</div>
<div class="line"><span class="comment">// now read b2, YARP will not touch it until the next call to read().</span></div>
<div class="line"><span class="comment">// The object pointed to by b1 can be re-cycled by YARP to store new data. </span></div>
<div class="line"><span class="comment">// If you access b1 you may get garbage. </span></div>
</div><!-- fragment --><p>Notice, however, that you never run in troubles if you follow the best practice and access messages in a loop, i.e.:</p>
<div class="fragment"><div class="line">BufferedPort&lt;Bottle&gt; port;</div>
<div class="line">...</div>
<div class="line">while (<span class="keyword">true</span>) {</div>
<div class="line">   Bottle *b1=port.read();</div>
<div class="line">   <span class="comment">// It is safe to read b1, YARP will not touch it.</span></div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>In the code above the scope of b1 automatically enforces safe access to the messages. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassyarp_1_1os_1_1Port_html_a1b49511d808f5731e2f7cf9e9831ff5e"><div class="ttname"><a href="classyarp_1_1os_1_1Port.html#a1b49511d808f5731e2f7cf9e9831ff5e">yarp::os::Port::write</a></div><div class="ttdeci">bool write(const PortWriter &amp;writer, const PortWriter *callback=nullptr) const override</div><div class="ttdoc">Write an object to the port.</div><div class="ttdef"><b>Definition:</b> <a href="Port_8cpp_source.html#l00440">Port.cpp:440</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li><span id="projectname_footer">YARP</span></li>
    <li><span id="projectnumber" class="version_switch">3.1.2</span></li>
    <li class="footer">Generated on Tue Nov 3 2020 16:43:15 for YARP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
